

<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>字斟・句酌</title>
<link rel="preconnect" href="https://fonts.googleapis.com">

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+TC:wght@400;600;700&display=swap" rel="stylesheet">

<style>

/* --- [修訂] 測驗按鈕光暈與點擊效果 --- */

/* 1. 定義「光暈」的脈動效果 (此部分保留不變) */
@keyframes pulse-glow {
  0%, 100% {
    /* 使用 var(--accent-color) 確保主題一致性 */
    box-shadow: 0 0 8px 2px rgba(122, 158, 159, 0.2); 
  }
  50% {
    box-shadow: 0 0 12px 5px rgba(122, 158, 159, 0.5);
  }
}

/* 2. 設定測驗按鈕的「平時」樣式 */
#quiz-btn {
  /* position: relative 已經不再需要，因為沒有偽元素了 */
  overflow: visible; /* 確保光暈不會被裁切 */
  animation: pulse-glow 3s infinite ease-in-out;
  transition: transform 0.1s ease, background-color 0.1s ease; /* 為了點擊時的縮放和顏色變化更平滑 */
}

/* 3. 新增按鈕被「點擊時」(:active) 的樣式 */
#quiz-btn:active {
  /* (a) 立即停止平時的脈動動畫 */
  animation: none;
  
  /* (b) 改變背景色，提供明確的視覺回饋 */
  /* 我們選用一個主題中的顏色 var(--accent-word) 作為點擊色 */
  background-color: var(--accent-word); 
  
  /* (c) 產生一個新的、更強烈的靜態光暈，顏色與背景色匹配 */
  box-shadow: 0 0 10px 4px rgba(163, 140, 148, 0.6); /* 這是 --accent-word 的 RGBA 版本 */

  /* (d) 增加一個輕微的內縮效果，模仿真實按鈕被按下的感覺 */
  transform: scale(0.95);
}

/* 4. 確保在點擊時，按鈕內的 SVG 圖示顏色能與新背景形成對比 */
#quiz-btn:active svg {
  /* 將圖示的線條顏色變為淺色，確保在深色背景下清晰可見 */
  stroke: var(--bg-color-light); 
}

    
/* --- 1. 核心與主題設定 (Core & Theming) --- */
:root {
/* 新的淡雅色彩主題 */
--bg-color-light: #EAF0ED; /* 淡雅灰綠 */
--text-primary-light: #5C554E; /* 深灰棕 */
--text-secondary-light: #A8A19A; /* 柔和灰 */
--content-bg-light: #F7F2EC; /* 柔和沙色 */
--border-color-light: #D9D2C9; /* 淺褐色 */
--accent-color: #7A9E9F; /* 雅緻青藍 */
--accent-color-hover: #688889;

/* 暗色主題 (基於新主題推衍) */
--bg-color-dark: #2C302E;
--text-primary-dark: #E0D9D1;
--text-secondary-dark: #918A81;
--content-bg-dark: #3F3A35;
--border-color-dark: #5C554E;

--overlay-bg: rgba(44, 48, 46, 0.7);

--font-sans: 'Noto Sans TC', sans-serif;
--font-serif: 'Noto Serif TC', serif;
--max-width: 900px;
--reader-font-size: 1.1rem;

/* 高亮顏色 */
--mark-original-bg-light: #FDEBCF; /* 柔和橘黃 */
--mark-polished-bg-light: #D6EBE5; /* 柔和薄荷綠 */
--mark-original-bg-dark: #6E5B3D;
--mark-polished-bg-dark: #3A5F5A;

/* [新增] 為兩種潤色模式定義專屬顏色 */
/* 詞彙潤色 (Word Polish) - 新增主題色 (灰紫) */
--accent-word: #A38C94;
--accent-word-hover: #917A82; 
--mark-bg-word-light: #EAE0E3;
--mark-bg-word-light: #EAE0E3; /* 淡雅藕粉 */
--mark-bg-word-dark: #59494F;

/* 文句潤色 (Prose Polish) - 沿用現有顏色 */
--accent-prose: var(--accent-color); /* 沿用青藍 */
--mark-bg-prose-light: var(--mark-polished-bg-light);
--mark-bg-prose-dark: var(--mark-polished-bg-dark);

/* [NEW] 測驗回饋顏色 */
--feedback-correct-color: #4CAF50; /* 一個明確的綠色 */
--feedback-incorrect-color: #e74c3c; /* 沿用錯誤訊息的紅色 */
--feedback-correct-bg-light: #e6f4e7;
--feedback-incorrect-bg-light: #fbe9e7;
--feedback-correct-bg-dark: #2e4b33;
--feedback-incorrect-bg-dark: #5a2d32;
--feedback-improve-color: #ff9800; /* 橙色用於建議改進 */
}

*, *::before, *::after {
box-sizing: border-box;
margin: 0;
padding: 0;
}

body {
font-family: var(--font-sans);
transition: background-color 0.4s, color 0.4s;
line-height: 1.8;
font-size: 16px;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}

body.light-mode {
background-color: var(--bg-color-light);
color: var(--text-primary-light);
}

body.dark-mode {
background-color: var(--bg-color-dark);
color: var(--text-primary-dark);
}

/* --- 2. 全域版面與容器 (Global Layout & Containers) --- */
.page-container {
display: grid;
place-items: center;
min-height: 100vh;
padding: 2rem 1rem;
}

.hidden { display: none !important; }

/* --- 3. UI 控制項 (UI Controls & Icons) --- */
.icon-btn {
background: none; border: none; cursor: pointer;
padding: 0.5rem; border-radius: 50%;
display: inline-flex; justify-content: center; align-items: center;
transition: background-color 0.2s, transform 0.2s;
}
.icon-btn svg {
width: 24px; height: 24px; stroke-width: 1.5;
transition: stroke 0.2s;
}
.light-mode .icon-btn svg { stroke: var(--text-primary-light); }
.dark-mode .icon-btn svg { stroke: var(--text-primary-dark); }
.light-mode .icon-btn:hover { background-color: rgba(0,0,0,0.05); }
.dark-mode .icon-btn:hover { background-color: rgba(255,255,255,0.1); }
.icon-btn:hover { transform: scale(1.1); }
.fullscreen-btn .icon-exit-fullscreen { display: none; }

/* --- 4. 主要區塊：設定、閱讀器 (Main Sections: Settings, Reader) --- */
.main-content-wrapper { width: 100%; max-width: var(--max-width); transition: all 0.4s ease-in-out; }
.settings-card, .reader-card {
border: 1px solid;
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
padding: 2rem 3rem;
transition: background-color 0.4s, border-color 0.4s;
backdrop-filter: blur(5px);
-webkit-backdrop-filter: blur(5px);
}
.light-mode .settings-card, .light-mode .reader-card { background-color: rgba(255, 255, 255, 0.5); border-color: var(--border-color-light); }
.dark-mode .settings-card, .dark-mode .reader-card { background-color: rgba(40, 38, 35, 0.7); border-color: var(--border-color-dark); }

/* --- 5. 設定區塊樣式 (Settings Section Styles) --- */
.settings-header { display: flex; justify-content: space-between; align-items: flex-start; position: relative; margin-bottom: 2rem; }
.settings-header .title-group { text-align: center; width: 100%; }
.settings-header .title-group h1 { font-family: var(--font-serif); font-weight: 700; font-size: 2.2rem; letter-spacing: 0.2em; margin-bottom: 0.5rem; }
.settings-header .title-group p { font-size: 1rem; }
.light-mode .settings-header .title-group p { color: var(--text-secondary-light); }
.dark-mode .settings-header .title-group p { color: var(--text-secondary-dark); }
.settings-header .header-controls { position: absolute; top: -12px; right: -16px; display: flex; align-items: center; gap: 0.25rem; }

/* Mode Switcher */
.mode-switcher {
display: grid;
grid-template-columns: repeat(2, 1fr);
justify-content: center;
margin-bottom: 2rem;
border-bottom: 1px solid;
flex-wrap: wrap;
}
.light-mode .mode-switcher { border-color: var(--border-color-light); }
.dark-mode .mode-switcher { border-color: var(--border-color-dark); }

/* --- [第一步：設定所有按鈕的基礎樣式] --- */
.mode-btn {
font-family: var(--font-sans);
font-size: 1rem;
font-weight: 500;
padding: 0.75rem 1.25rem;
border: none;
background-color: transparent;
cursor: pointer;
position: relative;
transition: color 0.3s, opacity 0.3s; /* 加上 opacity 過渡效果 */
}

/* 「查找」和「隨機」按鈕的預設顏色 (未選中) */
.light-mode .mode-btn { color: var(--text-secondary-light); }
.dark-mode .mode-btn { color: var(--text-secondary-dark); }

/* 「查找」和「隨機」按鈕被選中時的顏色 */
.light-mode .mode-btn.active { color: var(--text-primary-light); }
.dark-mode .mode-btn.active { color: var(--text-primary-dark); }


/* --- [第二步：專門為潤色按鈕設定不同的預設顏色] --- */

/* 「詞語」和「文句」潤色按鈕的預設顏色 (未選中) */
.mode-btn[data-mode="word-polish"],
.mode-btn[data-mode="prose-polish"] {
color: var(--accent-word); /* 直接套用灰紫色 */
opacity: 1; /* 但用透明度讓它變淡，表示未選中 */
}

/* --- [第三步：設定潤色按鈕被選中時的樣式] --- */

/* 「詞語」和「文句」潤色按鈕被選中時，變為實色 */
.mode-btn[data-mode="word-polish"].active,
.mode-btn[data-mode="prose-polish"].active {
color: var(--accent-word);
opacity: 1; /* 移除透明度，讓它變為飽和的實色 */
}

/* --- [第四步：統一所有按鈕的底線樣式] --- */

/* 所有按鈕共用的底線基礎樣式 */
.mode-btn::after {
content: '';
position: absolute;
bottom: -1px;
left: 0;
width: 100%;
height: 2px;
background-color: var(--accent-color); /* 預設為綠色 */
transform: scaleX(0);
transition: transform 0.3s ease-out, background-color 0.3s; /* 加上顏色過渡 */
}
.mode-btn.active::after {
transform: scaleX(1);
}

/* 潤色按鈕被選中時，底線變為紫色 */
.mode-btn[data-mode="word-polish"].active::after,
.mode-btn[data-mode="prose-polish"].active::after {
background-color: var(--accent-word);
}

/* 確保在暗色模式下也使用專屬顏色 */
.dark-mode .mode-btn[data-mode="word-polish"].active,
.dark-mode .mode-btn[data-mode="prose-polish"].active {
color: inherit;
}
.form-container { padding-top: 0.5rem; }
.form-group { margin-bottom: 1.75rem; }
.form-group label { display: block; margin-bottom: 0.75rem; font-weight: 500; font-size: 1.1rem; }

/* General input styles */
input[type="text"], input[type="search"], textarea, select {
width: 100%;
padding: 0.75rem 1rem;
border-radius: 0px; /* More minimalist */
font-family: inherit;
font-size: 1rem;
line-height: 1.6;
border: 1px solid;
transition: background-color 0.4s, color 0.4s, border-color 0.4s;
-webkit-appearance: none; -moz-appearance: none; appearance: none;
}
.light-mode input[type="text"], .light-mode input[type="search"], .light-mode textarea, .light-mode select {
background-color: transparent;
border-color: var(--border-color-light);
color: var(--text-primary-light);
}
.dark-mode input[type="text"], .dark-mode input[type="search"], .dark-mode textarea, .dark-mode select {
background-color: var(--bg-color-dark);
border-color: var(--border-color-dark);
color: var(--text-primary-dark);
}
input[type="text"]:focus, input[type="search"]:focus, textarea:focus, select:focus {
outline: none;
border-color: var(--accent-color);
box-shadow: 0 0 0 2px rgba(163, 155, 139, 0.3);
}

select {
background-repeat: no-repeat;
background-position: right 1rem center;
background-size: .65em auto;
cursor: pointer;
}
.light-mode select { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%233D3B37%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-13%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2013l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E'); }
.dark-mode select { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23D1CFCB%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-13%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2013l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E'); }

textarea { min-height: 120px; }

/* Difficulty Rating */
.rating-dots { display: flex; gap: 12px; cursor: pointer; }
.rating-dot { width: 28px; height: 28px; border-radius: 50%; border: 2px solid; transition: all 0.2s ease-in-out; }
.light-mode .rating-dot { border-color: #ccc; }
.dark-mode .rating-dot { border-color: #555; }
.rating-dots:hover .rating-dot, .rating-dots .rating-dot.selected { border-color: var(--accent-color); background-color: var(--accent-color); transform: scale(1.1); }
.rating-dots:hover .rating-dot:hover ~ .rating-dot { background-color: transparent; border-color: #ccc; }
.dark-mode .rating-dots:hover .rating-dot:hover ~ .rating-dot { border-color: #555; }
#error-message { color: #e74c3c; margin-top: 0.5rem; display: none; font-size: 0.9rem; text-align: center; }

.submit-btn {
background-color: var(--accent-color); color: var(--bg-color-light); border: none; padding: 0.75rem 1.75rem; cursor: pointer;
font-family: inherit; font-size: 1.1rem; font-weight: 500; transition: background-color 0.3s, transform 0.2s;
display: inline-flex; align-items: center; justify-content: center; gap: 10px; width: 100%; margin-top: 1rem; border-radius: 0;
}
.submit-btn:hover { background-color: var(--accent-color-hover); }
.submit-btn:active { transform: scale(0.98); }
.submit-btn:disabled { background-color: #cccccc; cursor: not-allowed; }
.loader { width: 20px; height: 20px; border: 3px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

/* --- [修訂] 新增的次要按鈕樣式 --- */
/* --- [修訂] 新增的次要按鈕樣式 (更新為預設填滿) --- */
/* --- [修訂] 新增的次要按鈕樣式 (線框樣式) --- */
.secondary-btn {
    /* 基礎樣式與 submit-btn 保持一致 */
    border: none;
    padding: 0.75rem 1.75rem;
    cursor: pointer;
    font-family: inherit;
    font-size: 1.1rem;
    font-weight: 500;
    transition: background-color 0.3s, color 0.3s, transform 0.2s;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
    margin-top: 1rem;
    border-radius: 0;

    /* 獨特的線框樣式 */
    background-color: transparent;            /* 背景設為透明 */
    border: 2px solid var(--accent-word);     /* 使用灰紫色作為邊框 */
    color: var(--accent-word);                /* 使用灰紫色作為文字顏色 */
}

.secondary-btn:hover {
    background-color: var(--accent-word);     /* 滑鼠懸浮時，背景才填滿灰紫色 */
    color: var(--bg-color-light);             /* 文字變為淺色以確保對比度 */
    transform: scale(1.02);                   /* 可以加個輕微的放大效果 */
}

.secondary-btn:active {
    transform: scale(0.98);
}

.secondary-btn:disabled {
    background-color: transparent;
    border-color: #cccccc;
    color: #cccccc;
    cursor: not-allowed;
}

/* --- 6. 詞彙結果頁面 (Reader Section) --- */
.reader-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding: 0 0.5rem; }
.reader-controls .left-controls, .reader-controls .right-controls { display: flex; align-items: center; gap: 0.5rem; }
.reader-pagination { font-family: var(--font-sans); font-size: 0.9rem; text-align: center; }
.light-mode .reader-pagination { color: var(--text-secondary-light); }
.dark-mode .reader-pagination { color: var(--text-secondary-dark); }
.font-controls { display: flex; align-items: center; gap: 0.25rem; border-right: 1px solid; padding-right: 0.75rem; margin-right: 0.25rem;}
.light-mode .font-controls { border-color: var(--border-color-light); }
.dark-mode .font-controls { border-color: var(--border-color-dark); }

/* --- 7. 詞彙展示區 (Book/Vocabulary Display) --- */
.book-container { width: 100%; height: 70vh; min-height: 500px; display: flex; justify-content: center; align-items: center; overflow: hidden; user-select: none; cursor: grab; margin-top: 0; margin-bottom: 2.5rem; }
.book-container:active { cursor: grabbing; }
.book { width: 100%; height: 100%; display: flex; }
.page { width: 100%; height: 100%; flex-shrink: 0; position: relative; border: 1px solid; }

.page-content {
width: 100%; height: 100%; padding: 3rem 2.5rem; overflow-y: auto;
font-family: var(--font-sans); font-size: var(--reader-font-size); line-height: 2;
}
.light-mode .page { background: var(--content-bg-light); border-color: var(--border-color-light); }
.dark-mode .page { background: var(--content-bg-dark); border-color: var(--border-color-dark); }
.light-mode .page-content { color: var(--text-primary-light); }
.dark-mode .page-content { color: var(--text-primary-dark); }

/* Vocabulary Display Styles */
.vocab-header {
font-family: var(--font-serif);
font-size: calc(var(--reader-font-size) + 1.5rem);
font-weight: 700;
margin-bottom: 1rem;
padding-bottom: 1rem;
border-bottom: 1px solid;
display: flex;
align-items: baseline;
gap: 1rem;
}
.light-mode .vocab-header { border-color: var(--border-color-light); }
.dark-mode .vocab-header { border-color: var(--border-color-dark); }

.vocab-definition-container {
background: rgba(163, 155, 139, 0.07);
border-left: 3px solid var(--accent-color);
padding: 1rem 1.5rem;
margin: 2.5rem 0;
}
.dark-mode .vocab-definition-container {
background: rgba(255, 255, 255, 0.05);
}
.vocab-definition {
font-size: calc(var(--reader-font-size) + 0.05rem);
font-family: var(--font-serif);
line-height: 1.9;
margin: 0; /* Override default p margin */
}
/* For polished text display */
.polished-text-content {
white-space: pre-wrap; /* Preserve paragraphs */
font-family: var(--font-serif);
font-size: calc(var(--reader-font-size) + 0.1rem);
line-height: 2;
}

.vocab-examples {
list-style-type: none; /* Remove default bullets */
padding-left: 0;
}
.vocab-examples li {
margin-bottom: 1.5em;
padding-left: 1.5em;
position: relative;
font-family: var(--font-serif);
letter-spacing: 0.05em;
font-size: calc(var(--reader-font-size) - 0.05rem);
}
.vocab-examples li::before {
content: '「';
position: absolute;
left: 0;
top: 0;
color: var(--accent-color);
font-weight: 600;
}
.vocab-examples li::after {
content: '」';
color: var(--accent-color);
font-weight: 600;
display: inline;
margin-left: 0.2em;
}

/* --- 8. 全螢幕模式 (Fullscreen Mode) --- */
body.fullscreen-mode { overflow: hidden; }
body.light-mode.fullscreen-mode { background-color: var(--content-bg-light); }
body.dark-mode.fullscreen-mode { background-color: var(--content-bg-dark); }
body.fullscreen-mode .page-container { padding: 0; }
body.fullscreen-mode .main-content-wrapper { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; max-width: none; z-index: 1000; }
body.fullscreen-mode .reader-card { border-radius: 0; border: none; box-shadow: none; height: 100%; display: flex; flex-direction: column; padding: 2rem; }
body.fullscreen-mode .book-container { flex-grow: 1; min-height: auto; height: auto; }
body.fullscreen-mode .fullscreen-btn .icon-enter-fullscreen { display: none; }
body.fullscreen-mode .fullscreen-btn .icon-exit-fullscreen { display: block; }

/* --- 9. 歷史紀錄彈窗 (History Modal) --- */
.history-modal {
position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--overlay-bg);
display: flex; justify-content: center; align-items: center; z-index: 2000;
opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0s 0.3s;
}
.history-modal.is-visible { opacity: 1; visibility: visible; transition-delay: 0s; }
.history-container {
width: 90%; max-width: 700px; max-height: 80vh; padding: 1.5rem 2rem;
display: flex; flex-direction: column; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
transform: scale(0.95); transition: transform 0.3s, background-color 0.4s;
border: 1px solid;
}
.light-mode .history-container { background-color: var(--content-bg-light); border-color: var(--border-color-light); }
.dark-mode .history-container { background-color: var(--content-bg-dark); border-color: var(--border-color-dark); }
.history-modal.is-visible .history-container { transform: scale(1); }
.history-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 1rem; margin-bottom: 1rem; border-bottom: 1px solid; }
.light-mode .history-header { border-color: var(--border-color-light); }
.dark-mode .history-header { border-color: var(--border-color-dark); }
.history-header h2 { font-size: 1.5rem; font-weight: 500; }

/* [NEW] History Tab Switcher */
.history-tab-switcher {
display: flex;
justify-content: center;
border-bottom: 1px solid;
margin-bottom: 1rem;
}
.light-mode .history-tab-switcher { border-color: var(--border-color-light); }
.dark-mode .history-tab-switcher { border-color: var(--border-color-dark); }
.history-tab-btn {
font-family: var(--font-sans); font-size: 1rem; font-weight: 500;
padding: 0.75rem 1.25rem; border: none; background-color: transparent;
cursor: pointer; position: relative; transition: color 0.3s;
}
.light-mode .history-tab-btn { color: var(--text-secondary-light); }
.dark-mode .history-tab-btn { color: var(--text-secondary-dark); }
.light-mode .history-tab-btn.active { color: var(--text-primary-light); }
.dark-mode .history-tab-btn.active { color: var(--text-primary-dark); }
.history-tab-btn::after {
content: ''; position: absolute; bottom: -1px; left: 0; width: 100%; height: 2px;
background-color: var(--accent-color); transform: scaleX(0); transition: transform 0.3s ease-out;
}
.history-tab-btn.active::after { transform: scaleX(1); }


.history-controls {
    display: flex;
    gap: 0.75rem; /* 從 1rem 縮小 */
    margin-bottom: 0.75rem; /* 從 1rem 縮小 */
}
#history-search {
    flex-grow: 1;
    padding: 0.4rem 0.75rem; /* 垂直內距從 0.5rem 縮小 */
    font-size: 0.9rem; /* 字體從 1rem 縮小 */
    font-family: var(--font-sans);
    border-radius: 0;
}
#history-sort {
    padding: 0.4rem; /* 內距從 0.5rem 縮小 */
    font-size: 0.9rem; /* 字體從 1rem 縮小 */
    font-family: var(--font-sans);
    border-radius: 0;
}
.light-mode #history-search, .light-mode #history-sort { background-color: var(--bg-color-light); border: 1px solid var(--border-color-light); color: var(--text-primary-light); }
.dark-mode #history-search, .dark-mode #history-sort { background-color: var(--bg-color-dark); border: 1px solid var(--border-color-dark); color: var(--text-primary-dark); }
#history-search:focus, #history-sort:focus { outline: none; border-color: var(--accent-color); }

.history-list { list-style: none; overflow-y: auto; flex-grow: 1; }
.history-list li { display: flex; justify-content: space-between; align-items: center; gap: 0.5rem; padding: 1rem; transition: background-color 0.2s; border-bottom: 1px solid; }
.history-list li.is-loading { opacity: 0.5; pointer-events: none; }
.history-list li:last-child { border-bottom: none; }
.history-item-content { flex-grow: 1; cursor: pointer; }
.history-list-item-title { font-family: var(--font-serif); font-size: 1.2rem; font-weight: 600; }
.history-list-item-meta { font-family: var(--font-sans); font-size: 0.9rem; margin-top: 0.25rem; }
.light-mode .history-list li { border-color: var(--border-color-light); }
.dark-mode .history-list li { border-color: var(--border-color-dark); }
.light-mode .history-list li:hover { background-color: rgba(0,0,0,0.03); }
.dark-mode .history-list li:hover { background-color: rgba(255,255,255,0.05); }
.light-mode .history-list-item-meta { color: var(--text-secondary-light); }
.dark-mode .history-list-item-meta { color: var(--text-secondary-dark); }
.history-item-actions { display: flex; align-items: center; gap: 0.25rem; }
.history-item-actions .icon-btn svg { width: 20px; height: 20px; }
.light-mode .delete-history-btn:hover svg, .light-mode #delete-all-history-btn:hover svg { stroke: #e74c3c; }
.dark-mode .delete-history-btn:hover svg, .dark-mode #delete-all-history-btn:hover svg { stroke: #e74c3c; }
/* [REVISION] Style for edit and regenerate buttons */
.light-mode .edit-history-title-btn:hover svg, .light-mode .regenerate-history-btn:hover svg { stroke: var(--accent-color-hover); }
.dark-mode .edit-history-title-btn:hover svg, .dark-mode .regenerate-history-btn:hover svg { stroke: var(--accent-color-hover); }

.no-history-msg { padding: 2rem; text-align: center; justify-content: center; }
.light-mode .no-history-msg { color: var(--text-secondary-light); }
.dark-mode .no-history-msg { color: var(--text-secondary-dark); }

  /* --- [新增] 針對手機版紀錄版面的響應式優化 --- */
@media (max-width: 600px) {
    /* 1. 將控制項容器改為垂直堆疊 */
    .history-controls {
        flex-direction: column; /* 從水平改為垂直 */
        gap: 0.5rem;            /* 縮小垂直間距 */
    }

    /* 2. 稍微縮小整個彈出視窗的內邊距，爭取更多空間 */
    .history-container {
        padding: 1.25rem 1rem;
    }

    /* 3. 縮小列表項目的垂直內邊距，讓列表更緊湊 */
    .history-list li {
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
    }

    /* 4. 微調列表項目的字體大小，使其更適合小螢幕 */
    .history-list-item-title {
        font-size: 1.1rem;
    }
    .history-list-item-meta {
        font-size: 0.85rem;
    }
}

/* --- 10. 響應式設計 (Responsive Design) --- */
@media (max-width: 768px) {
.main-content-wrapper { width: 95%; }
.page-container { padding: 1rem 0; }
.settings-card, .reader-card { padding: 1.5rem; box-shadow: none; }
body.fullscreen-mode .reader-card { padding: 1.5rem; }
.settings-header { margin-bottom: 2rem; flex-direction: column; align-items: center; gap: 0.75rem; }
.settings-header .title-group h1 { font-size: 1.8rem; }
.settings-header .header-controls { position: static; }
.mode-btn { padding: 0.75rem 1rem; }
.reader-controls .left-controls, .reader-controls .right-controls { gap: 0.2rem; }
.page-content { padding: 2rem 1.5rem; }
.history-controls { flex-direction: column; }
}

/* --- 11. 版權聲明 (Copyright) --- */
.copyright-footer {
position: fixed;
bottom: 0;
right: 0;
padding: 5px 10px;
z-index: 500;
transition: background-color 0.4s, color 0.4s;
}
.light-mode .copyright-footer { background-color: var(--bg-color-light); }
.dark-mode .copyright-footer { background-color: var(--bg-color-dark); }
.copyright-footer p { margin: 0; font-size: 14px; }
.light-mode .copyright-footer p { color: var(--text-secondary-light); }
.dark-mode .copyright-footer p { color: var(--text-secondary-dark); }
@media (max-width: 600px) { .copyright-footer p { font-size: 12px; } }

/* --- 12. [REVISION] 通用比對與檢視樣式 --- */
.view-switcher {
display: flex;
gap: 0.5rem;
margin-bottom: 1.5rem;
border-bottom: 1px solid;
}
.light-mode .view-switcher { border-color: var(--border-color-light); }
.dark-mode .view-switcher { border-color: var(--border-color-dark); }
.view-btn {
font-family: var(--font-sans);
font-size: 0.9rem;
font-weight: 500;
padding: 0.5rem 1rem;
border: none;
background-color: transparent;
cursor: pointer;
position: relative;
transition: color 0.3s;
margin-bottom: -1px;
}
.light-mode .view-btn { color: var(--text-secondary-light); }
.dark-mode .view-btn { color: var(--text-secondary-dark); }

/* [修訂] 讓檢視按鈕的 active 狀態顏色也根據模式改變 */
.view-btn.active {
border-bottom: 2px solid var(--accent-prose); /* 預設為文句潤色 (青藍) */
}
.word-polish-view .view-btn.active {
border-bottom-color: var(--accent-word); /* 覆寫為詞彙潤色 (灰紫) */
}
.light-mode .view-btn.active { color: var(--text-primary-light); }
.dark-mode .view-btn.active { color: var(--text-primary-dark); }

.comparison-container { display: flex; flex-direction: column; gap: 2rem; }
.comparison-pair {
display: grid;
grid-template-columns: 1fr;
gap: 1.5rem;
}
@media (min-width: 768px) {
.comparison-pair {
grid-template-columns: 1fr 1fr;
}
}


.original-para, .polished-para {
padding: 1rem 1.5rem;
border-radius: 4px;
line-height: 1.9;
font-family: var(--font-serif);
font-size: calc(var(--reader-font-size) - 0.05rem);
white-space: pre-wrap;
border: 1px solid;
}

/* [修訂] 為不同潤色模式設定不同背景色 */
.light-mode .original-para { background-color: #fdf8f2; border-color: var(--border-color-light); }
.dark-mode .original-para { background-color: #3a3631; border-color: var(--border-color-dark); }

.light-mode .prose-polish-view .polished-para { background-color: #f2f7fd; border-color: var(--border-color-light); } /* 文句潤色(青藍系) */
.dark-mode .prose-polish-view .polished-para { background-color: #2f3b48; border-color: var(--border-color-dark); }

.light-mode .word-polish-view .polished-para { background-color: #f7f2f4; border-color: var(--border-color-light); } /* 詞彙潤色(灰紫系) */
.dark-mode .word-polish-view .polished-para { background-color: #3e363a; border-color: var(--border-color-dark); }


.para-marker {
font-size: 0.9em;
font-weight: bold;
color: var(--text-secondary-light);
margin-bottom: 0.5rem;
font-family: var(--font-sans);
}
.dark-mode .para-marker {
color: var(--text-secondary-dark);
}

mark.mark-original {
background-color: var(--mark-original-bg-light);
color: inherit;
padding: 0.1em 0;
border-radius: 2px;
}
.dark-mode mark.mark-original {
background-color: var(--mark-original-bg-dark);
}

/* [修訂] 讓 mark 顏色根據父層容器的模式切換 */
mark.mark-polished {
background-color: var(--mark-bg-prose-light); /* 預設為文句潤色(青藍系) */
color: inherit;
padding: 0.1em 0;
border-radius: 2px;
border-bottom: 1px dotted var(--accent-prose);
}
.dark-mode mark.mark-polished {
background-color: var(--mark-bg-prose-dark);
}

/* 詞彙潤色模式的專屬覆寫 */
.word-polish-view mark.mark-polished {
background-color: var(--mark-bg-word-light); /* 覆寫為詞彙潤色(灰紫系) */
border-bottom-color: var(--accent-word);
}
.dark-mode .word-polish-view mark.mark-polished {
background-color: var(--mark-bg-word-dark);
}


/* --- [REVISION] Notification Toast --- */
.vocab-toast {
position: fixed;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
background-color: var(--accent-color);
color: var(--bg-color-light);
padding: 10px 20px;
border-radius: 5px;
z-index: 3000;
opacity: 0;
visibility: hidden;
transition: opacity 0.4s, visibility 0.4s, bottom 0.4s;
font-size: 0.9rem;
box-shadow: 0 3px 10px rgba(0,0,0,0.2);
}
.vocab-toast.show {
opacity: 1;
visibility: visible;
bottom: 30px;
}

/* --- 13. [NEW] 文句潤色模式樣式 (NOW USES GENERAL CLASSES) --- */
.prose-result-header {
font-family: var(--font-serif);
font-size: calc(var(--reader-font-size) + 0.8rem);
font-weight: 600;
text-align: center;
margin-bottom: 2rem;
padding-bottom: 1.5rem;
border-bottom: 1px solid;
}
.light-mode .prose-result-header { border-color: var(--border-color-light); }
.dark-mode .prose-result-header { border-color: var(--border-color-dark); }


/* --- 14. [NEW] 詞彙潤色模式擴充 (Word Polish Mode Extensions) --- */
.full-text-header {
display: flex;
justify-content: flex-end;
align-items: center;
margin-bottom: 0.5rem;
height: 36px;
}

.copy-full-text-btn svg {
width: 20px;
height: 20px;
}


/* --- 15. [NEW] 測驗模式 (Quiz Mode) --- */


#quiz-setup-screen::after,
#quiz-game-screen::after {
    content: '';
    display: block;
    height: 1.5rem; /* 這是您想要的空白距離，可自行調整 */
    flex-shrink: 0; /* 確保在 flex 佈局中這個空間不會被壓縮 */
}


.quiz-fullscreen-container {
position: fixed;
top: 0; left: 0;
width: 100vw; height: 100vh;
z-index: 1500;
display: flex;
flex-direction: column;
transition: background-color 0.4s, color 0.4s;
}
.light-mode .quiz-fullscreen-container { background-color: var(--bg-color-light); }
.dark-mode .quiz-fullscreen-container { background-color: var(--bg-color-dark); }

.quiz-header {
display: flex;
justify-content: space-between;
align-items: center;
padding: 1rem 1.5rem;
border-bottom: 1px solid;
flex-shrink: 0;
}
.light-mode .quiz-header { border-color: var(--border-color-light); }
.dark-mode .quiz-header { border-color: var(--border-color-dark); }

.quiz-header-left { display: flex; align-items: center; gap: 1rem; }
.quiz-header-left h2 { font-size: 1.5rem; font-weight: 500; }
.quiz-header-right { display: flex; align-items: center; gap: 0.5rem; }

#quiz-score {
font-size: 1.2rem;
font-weight: 500;
font-family: var(--font-sans);
}
.light-mode #quiz-score { color: var(--accent-color); }
.dark-mode #quiz-score { color: var(--accent-word); }

/* [修訂四] 題數計數器樣式 */
#quiz-progress-counter {
    font-size: 1rem;
    font-weight: 500;
    font-family: var(--font-sans);
}
.light-mode #quiz-progress-counter { color: var(--text-secondary-light); }
.dark-mode #quiz-progress-counter { color: var(--text-secondary-dark); }


.quiz-content {
flex-grow: 1;
overflow-y: auto;
padding: 2rem;
display: flex;
justify-content: center;
}

#quiz-setup-screen, #quiz-game-screen {
width: 100%;
max-width: var(--max-width);
display: flex;
flex-direction: column;
gap: 2.5rem;
 padding-bottom: 3rem;
}




.quiz-setup-section { text-align: left; }
.quiz-setup-label {
font-size: 1.2rem;
font-weight: 700;
font-family: var(--font-serif);
margin-bottom: 1.5rem;
padding-bottom: 0.75rem;
border-bottom: 1px solid;
}
.light-mode .quiz-setup-label { border-color: var(--border-color-light); }
.dark-mode .quiz-setup-label { border-color: var(--border-color-dark); }

.quiz-options-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
gap: 1rem;
}

.quiz-setting-btn {
background: none;
border: 1px solid;
padding: 1rem;
cursor: pointer;
font-size: 1rem;
font-family: var(--font-sans);
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
gap: 0.75rem;
transition: all 0.2s ease-in-out;
text-align: center;
}
.light-mode .quiz-setting-btn {
color: var(--text-secondary-light);
border-color: var(--border-color-light);
}
.dark-mode .quiz-setting-btn {
color: var(--text-secondary-dark);
border-color: var(--border-color-dark);
}
.quiz-setting-btn:hover {
transform: translateY(-5px);
box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}
.light-mode .quiz-setting-btn:hover { background-color: rgba(255,255,255,0.5); }
.dark-mode .quiz-setting-btn:hover { background-color: rgba(255,255,255,0.05); }

.light-mode .quiz-setting-btn.active {
color: var(--bg-color-light);
background-color: var(--accent-color);
border-color: var(--accent-color);
}
.dark-mode .quiz-setting-btn.active {
color: var(--bg-color-dark);
background-color: var(--accent-color);
border-color: var(--accent-color);
}
.quiz-setting-btn.active svg { stroke: currentColor; }

.quiz-setting-btn svg {
width: 32px; height: 32px;
margin-bottom: 0.25rem;
}

.quiz-scope-switcher {
display: flex;
border: 1px solid;
margin-bottom: 1rem;
}
.light-mode .quiz-scope-switcher { border-color: var(--border-color-light); }
.dark-mode .quiz-scope-switcher { border-color: var(--border-color-dark); }

.quiz-scope-btn {
flex-grow: 1;
background: none;
border: none;
padding: 0.75rem 1rem;
cursor: pointer;
font-size: 1rem;
transition: all 0.2s;
}
.quiz-scope-btn:first-child { border-right: 1px solid; }
.light-mode .quiz-scope-btn { color: var(--text-secondary-light); border-color: var(--border-color-light); }
.dark-mode .quiz-scope-btn { color: var(--text-secondary-dark); border-color: var(--border-color-dark); }

.light-mode .quiz-scope-btn.active { background-color: var(--content-bg-light); color: var(--text-primary-light); }
.dark-mode .quiz-scope-btn.active { background-color: var(--content-bg-dark); color: var(--text-primary-dark); }

.quiz-vocab-list-container {
border: 1px solid;
padding: 1rem;
}
.light-mode .quiz-vocab-list-container { border-color: var(--border-color-light); }
.dark-mode .quiz-vocab-list-container { border-color: var(--border-color-dark); }

.quiz-vocab-list-controls {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 1rem;
padding-bottom: 1rem;
border-bottom: 1px solid;
}
.light-mode .quiz-vocab-list-controls { border-color: var(--border-color-light); }
.dark-mode .quiz-vocab-list-controls { border-color: var(--border-color-dark); }
.quiz-vocab-list-controls button {
background: none;
border: 1px solid;
padding: 0.25rem 0.5rem;
font-size: 0.8rem;
cursor: pointer;
transition: all 0.2s;
margin-left: 0.5rem;
}
.light-mode .quiz-vocab-list-controls button { color: var(--text-primary-light); border-color: var(--border-color-light); }
.dark-mode .quiz-vocab-list-controls button { color: var(--text-primary-dark); border-color: var(--border-color-dark); }
.light-mode .quiz-vocab-list-controls button:hover { background-color: var(--bg-color-light); }
.dark-mode .quiz-vocab-list-controls button:hover { background-color: var(--bg-color-dark); }


.quiz-vocab-list {
list-style: none;
max-height: 25vh;
overflow-y: auto;
}
.quiz-vocab-list li {
padding: 0.75rem 1rem;
cursor: pointer;
transition: background-color 0.2s;
border-bottom: 1px solid;
display: flex;
align-items: center;
gap: 1rem;
}
.light-mode .quiz-vocab-list li { border-color: var(--border-color-light); }
.dark-mode .quiz-vocab-list li { border-color: var(--border-color-dark); }

.light-mode .quiz-vocab-list li:hover { background-color: var(--bg-color-light); }
.dark-mode .quiz-vocab-list li:hover { background-color: var(--bg-color-dark); }

.quiz-vocab-list li.selected {
font-weight: 700;
}
.light-mode .quiz-vocab-list li.selected { background-color: var(--mark-polished-bg-light); }
.dark-mode .quiz-vocab-list li.selected { background-color: var(--mark-polished-bg-dark); }

.quiz-vocab-list li::before {
content: '☐';
font-family: sans-serif;
font-size: 1.2rem;
}
.quiz-vocab-list li.selected::before {
content: '☑';
color: var(--accent-color);
}

.quiz-start-container { text-align: center; }
#quiz-error-message { color: var(--feedback-incorrect-color); margin-top: 1rem; }

/* Game Screen */
.quiz-question-container {
padding: 2rem;
font-size: 1.5rem;
font-family: var(--font-serif);
text-align: center;
line-height: 1.8;
min-height: 150px;
display: flex;
align-items: center;
justify-content: center;
}


/* --- [修訂] 針對特定題型，加大題目字體 --- */
.quiz-question-container.quiz-type-1,
.quiz-question-container.quiz-type-5 {
    font-size: 3rem;   /* 將字體從 1.5rem 加大到 2.5rem */
    font-weight: 700;    /* 稍微加粗，增加強調效果 */
    line-height: 1.5;    /* 調整行高以適應更大的字體 */
}


.quiz-question-container .placeholder {
font-style: italic;
font-size: 1rem;
color: var(--text-secondary-light);
}
.dark-mode .quiz-question-container .placeholder { color: var(--text-secondary-dark); }

.quiz-answer-options {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 1.5rem;
}

.quiz-option {
width: 100%;
background: none;
border: 1px solid;
padding: 1.25rem;
text-align: left;
font-size: 1.1rem;
font-family: var(--font-sans);
cursor: pointer;
transition: all 0.2s;
}
.light-mode .quiz-option { border-color: var(--border-color-light); color: var(--text-primary-light); }
.dark-mode .quiz-option { border-color: var(--border-color-dark); color: var(--text-primary-dark); }

.light-mode .quiz-option:not(:disabled):hover { background-color: var(--content-bg-light); border-color: var(--accent-color); }
.dark-mode .quiz-option:not(:disabled):hover { background-color: var(--content-bg-dark); border-color: var(--accent-color); }

.quiz-option.correct {
background-color: var(--feedback-correct-bg-light) !important;
border-color: var(--feedback-correct-color) !important;
color: var(--feedback-correct-color) !important;
font-weight: 700;
}
.dark-mode .quiz-option.correct {
background-color: var(--feedback-correct-bg-dark) !important;
}

.quiz-option.incorrect {
background-color: var(--feedback-incorrect-bg-light) !important;
border-color: var(--feedback-incorrect-color) !important;
color: var(--feedback-incorrect-color) !important;
font-weight: 700;
}
.dark-mode .quiz-option.incorrect {
background-color: var(--feedback-incorrect-bg-dark) !important;
}

.quiz-option:disabled {
cursor: not-allowed;
opacity: 0.8;
}

.quiz-feedback-container {
min-height: 50px;
display: flex;
align-items: center;
justify-content: center;
padding-top: 1rem;
}
#quiz-feedback-text {
font-size: 1.2rem;
font-weight: 700;
padding: 0.5rem 1rem;
border-radius: 4px;
}
#quiz-feedback-text.correct {
color: var(--feedback-correct-color);
background-color: var(--feedback-correct-bg-light);
}
.dark-mode #quiz-feedback-text.correct {
background-color: var(--feedback-correct-bg-dark);
}
#quiz-feedback-text.incorrect {
color: var(--feedback-incorrect-color);
background-color: var(--feedback-incorrect-bg-light);
}
.dark-mode #quiz-feedback-text.incorrect {
background-color: var(--feedback-incorrect-bg-dark);
}

#quiz-sentence-area {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-top: 1.5rem;
}
#quiz-sentence-input {
    width: 100%;
    min-height: 100px;
    font-size: 1.1rem;
    padding: 1rem;
    resize: vertical;
}
#quiz-ai-feedback-area {
    width: 100%;
    padding: 1rem;
    border-left: 4px solid;
    display: flex;
    align-items: center;
    gap: 1rem;
    /* [修訂] 增加垂直方向的外邊距，以創造空間感 */
    margin-top: 2rem;
    margin-bottom: 2rem;
}

#quiz-ai-feedback-area.appropriate { border-color: var(--feedback-correct-color); }
#quiz-ai-feedback-area.needs-improvement { border-color: var(--feedback-improve-color); }
#quiz-ai-feedback-area.incorrect { border-color: var(--feedback-incorrect-color); }

#quiz-ai-comment {
    margin: 0;
    line-height: 1.7;
    flex-grow: 1;
}

@media (max-width: 768px) {
    .quiz-options-grid { grid-template-columns: 1fr; }
    .quiz-answer-options { grid-template-columns: 1fr; }
    .quiz-content { padding: 1.5rem; }
    .quiz-header-left { flex-wrap: wrap; gap: 0.75rem; }
    .quiz-header-left h2 { font-size: 1.2rem; }
    #quiz-score { font-size: 1rem; }
    #quiz-progress-counter { font-size: 0.9rem; }
    .quiz-question-container { font-size: 1.2rem; padding: 1rem; }
}

mark.mark-polished.is-loading {
    cursor: wait;
    opacity: 0.5;
}

/* --- [修訂] 覆寫「混合題型」選項的啟用顏色 --- */
#quiz-mix-selection .quiz-setting-btn.active {
    background-color: var(--accent-word); /* 使用灰紫色 */
    border-color: var(--accent-word);     /* 同步更新邊框顏色 */
}


  /* --- 通用輸入框懸浮視窗 (CSS) --- */

/* 1. 讓所有符合條件的輸入框看起來可以點擊 */
textarea:not(.no-modal-editor),
input[type="text"]:not(.no-modal-editor) {
    cursor: pointer; /* 滑鼠變成手形指標 */
    background-color: #f0f8ff; /* 淡藍色背景提示 */
    transition: background-color 0.2s;
}

/* 2. 當滑鼠懸停時，背景色稍深一點 */
textarea:not(.no-modal-editor):hover,
input[type="text"]:not(.no-modal-editor):hover {
    background-color: #e6f2ff;
}

/* 3. 懸浮視窗本身的樣式 */
.outline-modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.65);
    z-index: 2000;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    box-sizing: border-box;
}

.outline-modal-content {
    background-color: #fdfdfd;
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    width: 90%;
    max-width: 700px;
    position: relative;
    animation: fadeIn 0.3s;
    display: flex;
    flex-direction: column;
}

.outline-modal-content h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #333;
    font-size: 1.2em;
    font-weight: 700;
}

#modal-textarea {
    width: 100%;
    box-sizing: border-box;
    font-size: 1.3em;
    line-height: 1.6;
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 10px;
    flex-grow: 1;
    min-height: 250px;
}

.outline-modal-content .modal-buttons {
    text-align: right;
    margin-top: 15px;
}

.outline-modal-content .preview-close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
}

/* 您可能也需要複製 .btn-action 和 .preview-close-btn 的樣式，如果您的工具中尚未定義它們 */
.btn-action {
    display: inline-block;
    padding: 10px 20px;
    margin: 5px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    color: white;
    background-color: rgba(31, 122, 85, 0.8);
    backdrop-filter: blur(5px);
}
.btn-action:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(110%);
}
.preview-close-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255, 255, 255, 0.7);
    border: none;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    cursor: pointer;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s, color 0.3s;
    z-index: 2010;
}
.preview-close-btn:hover {
    color: #fff;
    background-color: #d32f2f;
}

	/* =========================================
   === [修復] 筆順演練視窗樣式 (請貼入 style 標籤內) ===
   ========================================= */

/* 1. 外層遮罩：確保預設不佔位 (display: none)，並浮在最上層 */
.stroke-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.75); /* 半透明黑底 */
    z-index: 9999; /* 確保層級最高，蓋過其他內容 */
    
    /* 彈性佈局：讓內容置中 */
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    
    backdrop-filter: blur(4px); /* 背景模糊效果 */
}

/* 當視窗被啟動時的樣式 */
.stroke-modal.is-visible {
    display: flex !important; /* 強制顯示 */
    animation: fadeIn 0.3s ease-out;
}

/* 簡單的淡入動畫 */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* 2. 視窗本體 */
.stroke-modal-content {
    background-color: #fdfcf8; /* 預設亮色底 */
    width: 90%;
    max-width: 420px; /* 限制最大寬度 */
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 10px 40px rgba(0,0,0,0.4);
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 1px solid #ccc;
}

/* Dark Mode 支援 */
.dark-mode .stroke-modal-content {
    background-color: #2C302E;
    border-color: #5C554E;
    color: #E0D9D1;
}

/* 3. 標題區 */
.stroke-header {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #ddd;
}
.dark-mode .stroke-header { border-bottom-color: #555; }

.stroke-header h2 {
    font-family: 'Noto Serif TC', serif;
    font-size: 1.4rem;
    margin: 0;
    font-weight: bold;
}

/* 4. 字元切換按鈕 (多字時顯示) */
.char-switcher {
    display: flex;
    gap: 8px;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    justify-content: center;
    min-height: 10px;
}

.char-btn {
    width: 36px;
    height: 36px;
    border: 1px solid #ccc;
    background: transparent;
    border-radius: 50%;
    font-size: 1.1rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}
.dark-mode .char-btn {
    border-color: #666;
    color: #bbb;
}

.char-btn.active {
    background-color: #7A9E9F; /* 主題色 */
    color: #fff;
    border-color: #7A9E9F;
    transform: scale(1.1);
    font-weight: bold;
}

/* 5. 狀態提示文字 */
.stroke-status {
    height: 1.5rem;
    font-size: 0.95rem;
    color: #7A9E9F;
    margin-bottom: 0.5rem;
    font-weight: 500;
    text-align: center;
}

/* 6. 米字格容器 (關鍵) */
.hanzi-container-wrapper {
    position: relative;
    width: 300px;
    height: 300px;
    margin-bottom: 1.5rem;
    background-color: #fff;
    border: 3px solid #8d6e63;
    
    /* 米字格背景線條 */
    background-image: 
        linear-gradient(to right, #d69a92 1px, transparent 1px),
        linear-gradient(to bottom, #d69a92 1px, transparent 1px),
        linear-gradient(45deg, transparent 49.5%, #d69a92 49.5%, #d69a92 50.5%, transparent 50.5%),
        linear-gradient(-45deg, transparent 49.5%, #d69a92 49.5%, #d69a92 50.5%, transparent 50.5%);
    background-size: 100% 100%;
    background-position: center;
    cursor: crosshair; /* 讓滑鼠變成十字，提示可書寫 */
}

/* Dark Mode 讓米字格稍暗一點以免刺眼 */
.dark-mode .hanzi-container-wrapper {
    filter: brightness(0.85);
}

#hanzi-target {
    width: 100%;
    height: 100%;
}

/* 7. 底部控制按鈕 */
.stroke-controls {
    display: flex;
    gap: 1rem;
    width: 100%;
}

.stroke-controls button {
    flex: 1; /* 按鈕平均分配寬度 */
}

/* 修正關閉按鈕樣式 */
#stroke-close-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
}
#stroke-close-btn:hover {
    background-color: rgba(0,0,0,0.1);
    border-radius: 50%;
}
.dark-mode #stroke-close-btn:hover {
    background-color: rgba(255,255,255,0.1);
}

	/* [修復] 強制讓視窗可以被點擊 */
.stroke-modal-content {
    pointer-events: auto !important;
}
.stroke-modal {
    pointer-events: auto !important;
}

</style>
</head>
<body class="light-mode">

<!-- Main Content -->
<div class="page-container">
<div class="main-content-wrapper">
<!-- 設定卡片 (初始顯示) -->
<section class="settings-card" id="settings-section">
<header class="settings-header">
<div class="title-group">
<h1>字斟・句酌</h1>
<p>煉字琢句——對思想最大的忠誠。</p>
</div>
<div class="header-controls">
<!-- [NEW] 測驗按鈕 -->
<button class="icon-btn" id="quiz-btn" title="開始測驗">
<!-- Graduation Cap Icon -->
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10v6M2 10l10-5 10 5-10 5z"></path><path d="M6 12v5c0 1.66 4 3 6 3s6-1.34 6-3v-5"></path></svg>
</button>
<button class="icon-btn" id="history-btn" title="查看紀錄">
<!-- Book Icon -->
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20v2H6.5A2.5 2.5 0 0 1 4 19.5z"></path><path d="M4 5h16v12H6.5A2.5 2.5 0 0 1 4 14.5V5zM7 7v2m3-2v2"></path></svg>
</button>
<button class="icon-btn theme-switcher-btn" id="settings-theme-switcher" title="切換主題">
<svg class="icon-theme-light" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
<svg class="icon-theme-dark hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
</button>
</div>
</header>

<div class="mode-switcher">
<button class="mode-btn active" data-mode="lookup">查考義例</button>
<button class="mode-btn" data-mode="generate">漫遊詞海</button>
<button class="mode-btn" data-mode="word-polish">潤色詞彙</button>
<button class="mode-btn" data-mode="prose-polish">潤色文句</button>
</div>

<div class="form-container">
<!-- 查找詞彙表單 (預設顯示) -->
<form id="lookup-form">
<div class="form-group">
<label for="lookup-word">查考</label>
<input type="text" id="lookup-word" class="no-modal-editor" placeholder="輸入一個詞彙...">
</div>
</form>

<!-- 隨機生成表單 (預設隱藏) -->
<form id="generate-form" class="hidden">
<div class="form-group">
<label for="generate-difficulty">深度</label>
<div class="rating-dots" id="generate-difficulty-rating" data-rating="2">
<div class="rating-dot" data-value="1"></div><div class="rating-dot selected" data-value="2"></div>
<div class="rating-dot" data-value="3"></div>
</div>
</div>
<div class="form-group">
<label for="word-count">數量</label>
<select id="word-count">
<option value="1">1</option>
<option value="2">2</option>
<option value="3" selected>3</option>
<option value="4">4</option>
<option value="5">5</option>
</select>
</div>
<div class="form-group">
<label for="prompt">主題</label>
<textarea id="prompt" class="no-modal-editor" placeholder="可輸入關鍵詞，引導尋詞方向..."></textarea>
</div>
</form>

<!-- [MODIFIED] 詞彙潤色模式表單 -->
<form id="word-polish-form" class="hidden">
<div class="form-group">
<label for="word-polish-text">原文</label>
<textarea id="word-polish-text" placeholder="在此輸入您希望潤色「詞彙」的段落或文章..."></textarea>
</div>
<div class="form-group">
<label for="word-polish-difficulty">深度</label>
<div class="rating-dots" id="word-polish-difficulty-rating" data-rating="3">
<div class="rating-dot" data-value="1"></div><div class="rating-dot" data-value="2"></div>
<div class="rating-dot selected" data-value="3"></div><div class="rating-dot" data-value="4"></div>
<div class="rating-dot" data-value="5"></div>
</div>
</div>
</form>

<!-- [NEW] 文句潤色模式表單 -->
<form id="prose-polish-form" class="hidden">
<div class="form-group">
<label for="prose-polish-text">原文</label>
<textarea id="prose-polish-text" placeholder="在此輸入您希望潤色「文句」的段落或文章..."></textarea>
</div>
<div class="form-group">
<label for="prose-polish-difficulty">風格</label>
<div class="rating-dots" id="prose-polish-difficulty-rating" data-rating="3">
<div class="rating-dot" data-value="1"></div><div class="rating-dot" data-value="2"></div>
<div class="rating-dot selected" data-value="3"></div><div class="rating-dot" data-value="4"></div>
<div class="rating-dot" data-value="5"></div>
</div>
</div>
</form>

<button type="submit" id="submit-btn" class="submit-btn">
<span class="btn-text">開始查考</span>
</button>
<div id="error-message"></div>
</div>
</section>


<!-- 閱讀器卡片 (初始隱藏) -->
<section class="reader-card hidden" id="reading-section">
<div class="reader-controls">
<div class="left-controls">
<button class="icon-btn" id="back-to-settings-btn" title="返回設定">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
</button>
</div>
<div id="reader-pagination" class="reader-pagination"></div>
<div class="right-controls">
<div class="font-controls">
<button class="icon-btn" id="font-size-decrease-btn" title="縮小字體">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:20px; height:20px;"><path d="M4 12h8m-8 0v-2a2 2 0 0 1 2-2h2"/><path d="M4 7V6a2 2 0 0 1 2-2h2"/><path d="M10 7V6a2 2 0 0 1 2-2h1"/><text x="16" y="16" font-size="10" font-family="sans-serif" text-anchor="middle">A</text></svg>
</button>
<button class="icon-btn" id="font-size-increase-btn" title="放大字體">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:22px; height:22px;"><path d="M4 12h8m-8 0v-2a2 2 0 0 1 2-2h2"/><path d="M4 7V6a2 2 0 0 1 2-2h2"/><path d="M10 7V6a2 2 0 0 1 2-2h1"/><text x="17" y="17" font-size="12" font-family="sans-serif" text-anchor="middle">A</text></svg>
</button>
</div>
<button class="icon-btn theme-switcher-btn" id="reader-theme-switcher" title="切換主題">
<svg class="icon-theme-light" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
<svg class="icon-theme-dark hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
</button>
<button class="icon-btn fullscreen-btn" id="fullscreen-btn" title="全螢幕模式">
<svg class="icon-enter-fullscreen" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
<svg class="icon-exit-fullscreen" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 0-2-2h-3m-12 0H5a2 2 0 0 0-2 2v3"></path></svg>
</button>
</div>
</div>
<div class="book-container" id="book-container">
<div class="book" id="book"></div>
</div>
</section>
</div>
</div>

<!-- [REVISED] 歷史紀錄彈出層 (Modal) -->
<div class="history-modal" id="history-modal">
<div class="history-container">
<div class="history-header">
<div style="display: flex; align-items: center; gap: 0.75rem;">
<h2 id="history-title">紀錄中心</h2>
</div>
<button class="icon-btn" id="history-close-btn" title="關閉">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
</button>
</div>

<div class="history-tab-switcher">
<button class="history-tab-btn active" data-history-type="lookup">詞彙表</button>
<button class="history-tab-btn" data-history-type="polishing">潤色紀錄</button>
</div>

<div class="history-controls">
<input type="search" id="history-search" class="no-modal-editor" placeholder="按詞彙搜尋...">
<select id="history-sort"></select> <!-- Options will be populated by JS -->
</div>
<ul class="history-list" id="history-list"></ul>
<div class="history-footer" style="padding-top: 1rem; text-align: right;">
<button class="icon-btn" id="delete-all-history-btn" title="刪除此分頁的所有紀錄">
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
</button>
</div>
</div>
</div>

<!-- [NEW] 測驗全螢幕模式 -->
<div class="quiz-fullscreen-container hidden" id="quiz-container">
    <!-- Quiz Header -->
    <div class="quiz-header">
        <div class="quiz-header-left">
            <button class="icon-btn" id="quiz-back-btn" title="返回設定">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
            </button>
            <h2 id="quiz-title">測驗設定</h2>
            <div id="quiz-score" class="hidden">分數：<span id="quiz-score-value">0</span></div>
            <!-- [修訂四] 新增題數計數器 -->
            <div id="quiz-progress-counter" class="hidden"></div>
        </div>
        <div class="quiz-header-right">
            <button class="icon-btn theme-switcher-btn" id="quiz-theme-switcher" title="切換主題">
                <svg class="icon-theme-light" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                <svg class="icon-theme-dark hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            </button>
        </div>
    </div>

    <!-- Quiz Content Area -->
    <div class="quiz-content">
        <!-- Setup Screen -->
        <div id="quiz-setup-screen">
            <div class="quiz-setup-section">
                <h3 class="quiz-setup-label">一、選擇題型</h3>
                <div class="quiz-options-grid" id="quiz-type-selection">
                    <button class="quiz-setting-btn active" data-quiz-type="1" title="以詞彙為題目，然後以解釋為選項">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><path d="M14 2v6h6"/><path d="M9 15h1"/><path d="M14 15h1"/><path d="M9 18h6"/></svg>
                        <span>詞彙 → 解釋</span>
                    </button>
                    <button class="quiz-setting-btn" data-quiz-type="2" title="以解釋為題目，然後以詞彙為選項">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20v2H6.5A2.5 2.5 0 0 1 4 19.5z"/><path d="M4 5h16v12H6.5A2.5 2.5 0 0 1 4 14.5V5z"/><path d="m10 8 2 2 2-2"/><path d="m12 12V8"/></svg>
                        <span>解釋 → 詞彙</span>
                    </button>
                    <button class="quiz-setting-btn" data-quiz-type="3" title="以空出關鍵詞彙的句子為題目，然後以詞彙為選項">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                        <span>句子填空</span>
                    </button>
                     <button class="quiz-setting-btn" data-quiz-type="5" title="由AI批改您的造句">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        <span>造句</span>
                    </button>
                    <button class="quiz-setting-btn" data-quiz-type="4" title="混合以上所有題型隨機出題">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="8 21 3 21 3 16"></polyline><line x1="15" y1="4" x2="3" y2="16"></line></svg>
                        <span>隨機混合</span>
                    </button>
                </div>
            </div>
            
            <!-- [REVISION START] New container for random mix options -->
            <div class="quiz-setup-section hidden" id="quiz-mix-options-container">
                <h3 class="quiz-setup-label">二、選擇混合題型</h3>
                <div class="quiz-options-grid" id="quiz-mix-selection">
                    <button class="quiz-setting-btn active" data-mix-type="1" title="以詞彙為題目，並以解釋為選項">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><path d="M14 2v6h6"/><path d="M9 15h1"/><path d="M14 15h1"/><path d="M9 18h6"/></svg>
                        <span>詞彙 → 解釋</span>
                    </button>
                    <button class="quiz-setting-btn active" data-mix-type="2" title="以解釋為題目，並以詞彙為選項">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20v2H6.5A2.5 2.5 0 0 1 4 19.5z"/><path d="M4 5h16v12H6.5A2.5 2.5 0 0 1 4 14.5V5z"/><path d="m10 8 2 2 2-2"/><path d="m12 12V8"/></svg>
                        <span>解釋 → 詞彙</span>
                    </button>
                    <button class="quiz-setting-btn active" data-mix-type="3" title="以隱去關鍵詞彙的句子為題目，並以詞彙為選項">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                        <span>句子填空</span>
                    </button>
                     <button class="quiz-setting-btn active" data-mix-type="5" title="由AI批改您的造句">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        <span>造句</span>
                    </button>
                </div>
            </div>
            <!-- [REVISION END] -->

            <div class="quiz-setup-section hidden" id="quiz-sentence-source-container">
                <h3 class="quiz-setup-label">二、選擇「句子填空」來源</h3>
                <div class="quiz-scope-switcher" id="quiz-sentence-source-selection">
                    <button class="quiz-scope-btn active" data-source="record">詞彙表例句</button>
                    <button class="quiz-scope-btn" data-source="ai">AI 出題</button>
                </div>
            </div>

            <div class="quiz-setup-section">
                <h3 class="quiz-setup-label" id="quiz-scope-label">三、選擇出題範圍</h3>
                <div class="quiz-scope-switcher" id="quiz-scope-selection">
                    <button class="quiz-scope-btn active" data-scope="all">所有詞彙</button>
                    <button class="quiz-scope-btn" data-scope="select">自選詞彙</button>
                </div>
                <div class="quiz-vocab-list-container hidden" id="quiz-vocab-selection-container">
                    <div class="quiz-vocab-list-controls">
                        <span>已選取 <span id="quiz-selected-count">0</span> 個詞彙</span>
                        <div>
                            <button id="quiz-select-all">全選</button>
                            <button id="quiz-deselect-all">取消全選</button>
                        </div>
                    </div>
                    <ul class="quiz-vocab-list" id="quiz-vocab-selection-list">
                        <!-- JS will populate this -->
                    </ul>
                </div>
            </div>

            <div class="quiz-start-container">
                <button id="quiz-start-btn" class="submit-btn">
                    <span class="btn-text">開始測驗</span>
                </button>
                <p id="quiz-error-message" class="hidden"></p>
            </div>
        </div>

        <!-- Game Screen -->
               <!-- Game Screen -->
        <div id="quiz-game-screen" class="hidden">
            <div class="quiz-question-container">
                 <p id="quiz-question-text"></p>
            </div>
            <div class="quiz-answer-options" id="quiz-options-area">
                <!-- JS populates buttons -->
            </div>
             <div id="quiz-sentence-area" class="hidden">
                <textarea id="quiz-sentence-input" class="no-modal-editor" placeholder="請使用上面的詞彙造句..."></textarea>
                <button id="quiz-sentence-submit" class="submit-btn">
                    <span class="btn-text">提交批改</span>
                </button>
            </div>
            
            <!-- [修訂] 在「提交批改」按鈕和 AI 回饋之間插入一個透明間隔 -->
            <div class="quiz-spacer"></div>

            <div class="quiz-feedback-container">
                <p id="quiz-feedback-text"></p>
                <div id="quiz-ai-feedback-area" class="hidden">
                    <p id="quiz-ai-comment"></p>
                </div>
            </div>

            <!-- [修訂] 在 AI 回饋和「下一題」按鈕之間插入一個透明間隔 -->
            <div class="quiz-spacer"></div>

           <!-- [修訂一] 新增手動跳轉按鈕 -->
            <button id="quiz-next-question-btn" class="secondary-btn hidden">
                <span class="btn-text">下一題</span>
            </button>
        </div>
    </div>
</div>


<footer class="copyright-footer">
<p>Copyright © 2025 陳冠健. All rights reserved.</p>
</footer>




<!-- [修正] 必須確保這段 HTML 存在於 body 內，JavaScript 才能抓到元素 -->
<div class="stroke-modal" id="stroke-modal">
    <div class="stroke-modal-content">
        <div class="stroke-header">
            <h2>筆順演練</h2>
            <button class="icon-btn" id="stroke-close-btn" title="關閉">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>
        
        <!-- 這就是報錯的 ID，必須存在 -->
        <div class="char-switcher" id="stroke-char-switcher"></div>

        <div class="stroke-status" id="stroke-status-text">準備就緒</div>

        <div class="hanzi-container-wrapper">
            <div id="hanzi-target"></div>
        </div>

        <div class="stroke-controls">
            <button id="stroke-animate-btn" class="secondary-btn">
                <span class="btn-text">播放動畫</span>
            </button>
            <button id="stroke-quiz-btn" class="submit-btn" style="margin-top:0;">
                <span class="btn-text">開始測驗</span>
            </button>
        </div>
    </div>
</div>


	
<div class="vocab-toast" id="vocab-toast"></div>



<script>
// ===============================================================
// === [神思通用組件] 嚴格權限鎖 (零容忍版) ===
// ===============================================================
(function() {
    // 防止重複注入
    if (window.SansiInterceptorLoaded) return;
    window.SansiInterceptorLoaded = true;

    // --- 1. 注入 CSS ---
    const style = document.createElement('style');
    style.textContent = `
        .sansi-limit-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(253, 252, 248, 0.95);
            backdrop-filter: blur(8px);
            z-index: 9999999;
            display: none; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.3s ease;
        }
        .sansi-limit-show { opacity: 1; }
        .sansi-limit-card {
            background: #fdfcf8; border: 1px solid #e0ddd7; border-radius: 16px;
            padding: 35px 25px; width: 90%; max-width: 380px;
            box-shadow: 0 15px 40px rgba(141, 110, 99, 0.2);
            text-align: center; transform: translateY(20px);
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            font-family: 'Noto Serif TC', serif;
        }
        .sansi-limit-show .sansi-limit-card { transform: translateY(0); }
        .sansi-limit-icon { font-size: 3.5rem; color: #d69a92; margin-bottom: 20px; }
        .sansi-limit-title { color: #5d4037; font-size: 1.5rem; font-weight: bold; margin: 0 0 15px 0; }
        .sansi-limit-desc { color: #666; font-size: 1.1rem; line-height: 1.6; margin-bottom: 30px; }
        .sansi-btn-group { display: flex; gap: 12px; margin-top: 10px; }
        .sansi-limit-btn {
            border: none; padding: 12px 0; border-radius: 50px;
            font-size: 1rem; font-weight: bold; cursor: pointer;
            transition: all 0.2s; font-family: 'Noto Serif TC', serif;
            flex: 1; display: flex; align-items: center; justify-content: center; gap: 8px;
            text-decoration: none;
        }
        .btn-primary { background: #8fa398; color: white; box-shadow: 0 4px 12px rgba(143, 163, 152, 0.4); }
        .btn-primary:hover { background-color: #7d9186; transform: translateY(-2px); }
        .btn-secondary { background: #f0f0f0; color: #777; }
        .btn-secondary:hover { background-color: #e5e5e5; }
    `;
    document.head.appendChild(style);

    // --- 2. 注入 HTML (連結指向上一層 index2.html) ---
    const modalHTML = `
        <div id="sansiLimitModal" class="sansi-limit-overlay">
            <div class="sansi-limit-card">
                <div class="sansi-limit-icon">
                    <i class="fas fa-lock"></i>
                </div>
                <div class="sansi-limit-title">會員限定功能</div>
                <div class="sansi-limit-desc">
                    此功能僅開放給神思登入用戶。<br>
                    請先登入學校帳號以繼續使用。
                </div>
                <div class="sansi-btn-group">
                    <button class="sansi-limit-btn btn-secondary" onclick="closeSansiLimitModal()">
                        取消
                    </button>
                    <button class="sansi-limit-btn btn-primary" onclick="window.location.href='../index2.html'">
                        <i class="fas fa-sign-in-alt"></i> 前往登入
                    </button>
                </div>
            </div>
        </div>
    `;
    const div = document.createElement('div');
    div.innerHTML = modalHTML;
    document.body.appendChild(div);

    // --- 3. 視窗控制 ---
    window.closeSansiLimitModal = function() {
        const modal = document.getElementById('sansiLimitModal');
        if (modal) {
            modal.classList.remove('sansi-limit-show');
            setTimeout(() => { modal.style.display = 'none'; }, 300);
            
            // 關閉 Loading 狀態 (適配字斟句酌的按鈕)
            const submitBtn = document.getElementById('submit-btn');
            if(submitBtn) setLoading(false, submitBtn); // 使用字斟句酌原本的 setLoading 函式
            
            const disabledBtns = document.querySelectorAll('button:disabled');
            disabledBtns.forEach(btn => btn.disabled = false);
        }
    };

    // --- 4. 嚴格攔截邏輯 ---
    const originalFetch = window.fetch;
    
    window.fetch = async function(url, options) {
        // 監測 AI 相關請求
        if (typeof url === 'string' && (url.includes('pollinations.ai') || url.includes('script.google.com'))) {
            
            const s = localStorage.getItem('studentProfile');
            
            // 如果有資料 -> 放行 (後續由 Token Injector 處理)
            if (s) {
                return originalFetch(url, options);
            }

            // 如果沒資料 -> 直接阻擋
            console.warn("🚫 [Sansi Security] 未登入用戶嘗試使用生成功能，已攔截。");
            
            const modal = document.getElementById('sansiLimitModal');
            modal.style.display = 'flex';
            void modal.offsetWidth; 
            modal.classList.add('sansi-limit-show');

            return Promise.reject(new Error("Login Required - Guest Access Denied"));
        }

        return originalFetch(url, options);
    };
    
    console.log("🔒 神思嚴格權限鎖 (必須登入) 已啟動");
})();
</script>







  
<script>


// 輔助函式：從 API 回應中提取純 JSON（剝離 Markdown 程式碼區塊）
function parseJsonFromResponse(content) {
    if (!content) return null;
    
    // 移除常見的 Markdown 包裝
    let cleanContent = content
        .replace(/^```(?:json)?\s*\n?/, '')
        .replace(/\n?```(?:\s*json)?$/, '')
        .trim();
    
    try {
        return JSON.parse(cleanContent);
    } catch (e) {
        console.warn('JSON 解析失敗，嘗試修復...', e);
        
        // 嘗試修復常見的 JSON 錯誤
        try {
            // 修復未終止的字符串
            const fixedContent = cleanContent.replace(
                /(\[\s*"[^"]*)(?=\s*,?\s*\])/g,
                (match) => match + '"'
            );
            
            // 修復缺少逗號的情況
            const fixedContent2 = fixedContent.replace(
                /"(\s*)(?=\])/g,
                '"$1'
            );
            
            return JSON.parse(fixedContent2);
        } catch (e2) {
            console.error('JSON 修復後仍然解析失敗:', e2, '原始內容:', content);
            
            // 嘗試提取部分有效數據
            const vocabMatch = cleanContent.match(/"vocab"\s*:\s*"([^"]+)"/);
            const definitionMatch = cleanContent.match(/"definition"\s*:\s*"([^"]+)"/);
            const examplesMatch = cleanContent.match(/"examples"\s*:\s*\[(.*?)\]/s);
            
            if (vocabMatch && definitionMatch) {
                const examples = [];
                if (examplesMatch) {
                    // 嘗試提取例句
                    const exampleText = examplesMatch[1];
                    const quoteMatches = exampleText.match(/"([^"]+)"/g);
                    if (quoteMatches) {
                        quoteMatches.forEach(match => {
                            examples.push(match.replace(/"/g, ''));
                        });
                    }
                }
                
                // 確保至少有3個例句
                while (examples.length < 3) {
                    examples.push("例句資料不完整");
                }
                
                return {
                    results: [{
                        vocab: vocabMatch[1],
                        definition: definitionMatch[1],
                        examples: examples.slice(0, 3)
                    }]
                };
            }
            
            return null;
        }
    }
}

  
// --- Main application logic ---
function initializeApp() {


const PREDEFINED_VOCABS = [
"安逸", "黯然", "翱翔", "懊惱", "拜謁", "斑駁", "斑斕", "褒貶", "悖謬", "鄙薄",
"鄙夷", "逼仄", "編撰", "便捷", "摒棄", "步履", "滄桑", "藏拙", "惻隱", "岑寂",
"孱弱", "諂媚", "猖獗", "塵寰", "沉痼", "沉吟", "馳騁", "彳亍", "憧憬", "躊躇",
"垂青", "垂範", "辭藻", "忖度", "稱譽", "大抵", "彈劾", "砥礪", "抵禦", "諦聽",
"玷辱", "凋敝", "跌宕", "杜撰", "端詳", "遏制", "噩耗", "發怔", "繁蕪", "悱惻",
"斐然", "憤懣", "風靡", "豐腴", "風韻", "付訖", "付梓", "哽咽", "躬行", "詬病",
"股肱", "關隘", "乖戾", "乖張", "廣袤", "無垠", "聒噪", "憨直", "更迭", "和煦",
"寰宇", "詰難", "厥辭", "攫取", "亢奮", "驀然", "恪守", "曠達", "匱乏", "濫觴",
"聯袂", "踉蹌", "寥廓", "寥落", "遴選", "夢囈", "渺茫", "泯滅", "暮靄", "寧謐",
"盤桓", "彌望", "翩然", "剽竊", "婆娑", "迄今", "阡陌", "戕害", "翹楚", "荏苒",
"蹂躪", "睿智", "嬗變", "涉獵", "深邃", "唆使", "坍塌", "恬淡", "偎依", "逶迤",
"紊亂", "希冀", "翔實", "軒昂", "湮滅", "怔忪", "諍言", "放曠", "沉鬱", "啜泣",
"逞強", "霎眼", "鐫刻", "抖擻", "髮綹", "洋溢", "酣睡", "囁嚅", "挑釁", "蟄伏",
"愣怔", "匍匐", "匍伏", "佇立", "褪色", "貪婪", "點綴", "顒望", "厄運", "澄清",
"湛藍", "枯涸", "哀嚎", "瑟縮", "倘若", "迥異", "訕笑", "喧囂", "空靈", "糜爛",
"編纂", "徑直", "窘境", "忸怩", "羞赧", "太息", "橫亙", "忤逆", "倚仗", "喋血",
"景仰", "啟迪", "偏袒", "崢嶸", "踟躕", "邂逅", "遐想", "牴觸", "浩淼", "躑躅",
"淡褪", "鞭笞", "罪孽", "惦記", "敦厚", "枕藉", "狼藉", "久違", "乍現", "紕漏",
"嗔怪", "應允", "蒼穹", "善變", "孤僻", "多愁善感", "達觀", "見異思遷", "豁達", "患得患失",
"耿直", "輕率", "專橫", "魯莽", "嘮叨", "頑固", "健談", "坦率", "沉穩", "腼腆",
"心胸狹隘", "輕佻", "狂妄", "糊塗", "謙遜", "溫文爾雅", "賢惠", "圓滑", "實事求是", "瞻前顧後",
"心扉", "瞥見", "打盹", "針砭", "整飭", "舛誤", "不啻", "沆瀣一氣", "腳踝", "恫嚇",
"晦澀", "拙劣", "嶄新", "儼如", "宛若", "莞爾", "周濟", "自詡", "修葺", "迢迢",
"跋扈", "籌措", "顯赫", "寬敞", "門檻", "裨益", "倉卒", "襤褸", "忐忑", "躡手躡腳",
"眩暈", "憊懶", "夢魘", "笑靨", "紈絝子弟", "隱匿", "嘀咕", "藐視", "雋永", "恢弘",
"夙願", "囹圄", "輿論", "昏厥", "釋然", "顰眉", "窺伺", "齷齪", "眷屬", "佝僂",
"遐邇", "緋紅", "齟齬", "耄耋", "倥傯", "趔趄", "攥住", "闌珊", "頃刻", "旋即",
"俄而", "洗濯", "肅殺", "蔭蔽", "熱忱", "瘡痍", "枉然", "猶豫", "顛沛", "睥睨",
"尋索", "覬覦", "詭譎", "慟哭", "頹唐", "兀自", "虛妄", "描摹", "悵然", "懼憚",
"焦灼", "韶華", "商榷", "哂笑", "濡濕", "摩挲", "恣情", "戲謔", "倉皇", "姹紫嫣紅",
"目送", "緣分",   "凝望", "交會", "倏忽", "靜寂",
"波濤", "空蕩", "落寞", "低垂", "排泄", "淚光", "暮色", "凝視", "羽衣", 
"窺伺", "湘繡", "錦緞", "翠綠", "嫣紅", "光華", "癡然",
"依戀", "輕撫",  "牢鎖", "集郵", "畫冊", "駐足",
"杜鵑", "流蘇", "勳章", "乾葉", "砧板", "直覺", "奢望", 
"嫻靜", "濃綠",  "白領", "狂熱", "熱流", "蜜月", "燭光", "心眼", "風箱", "彎曲", "忌恨", "埋葬", "墮地",
"本質", "鋒芒", "盈盈", "欣悅", "冰糖", "擦鍋",
"檢點", "上閂", "氤氳", "旖旎", "綽約", "徜徉", "縹緲",
"綺麗", "蒼茫", "巋然", "蕭瑟", "嶙峋",  "氤氳", "旖旎"
];


  
// --- 1. DOM 元素選擇 ---
const body = document.body;
const root = document.documentElement;
const settingsSection = document.getElementById('settings-section');
const readingSection = document.getElementById('reading-section');
const themeSwitchers = document.querySelectorAll('.theme-switcher-btn');

// Mode switcher
const modeBtns = document.querySelectorAll('.mode-btn');
const lookupForm = document.getElementById('lookup-form');
const generateForm = document.getElementById('generate-form');
const wordPolishForm = document.getElementById('word-polish-form');
const prosePolishForm = document.getElementById('prose-polish-form');

// Forms
const lookupWordInput = document.getElementById('lookup-word');
const generateDifficultyRating = document.getElementById('generate-difficulty-rating');
const wordCountSelect = document.getElementById('word-count');
const promptTextarea = document.getElementById('prompt');
const wordPolishTextarea = document.getElementById('word-polish-text');
const wordPolishDifficultyRating = document.getElementById('word-polish-difficulty-rating');
const prosePolishTextarea = document.getElementById('prose-polish-text');
const prosePolishDifficultyRating = document.getElementById('prose-polish-difficulty-rating');


const submitBtn = document.getElementById('submit-btn');
const submitBtnText = submitBtn.querySelector('.btn-text');
const errorMessage = document.getElementById('error-message');

// Reader
const book = document.getElementById('book');
const bookContainer = document.getElementById('book-container');
const fullscreenBtn = document.getElementById('fullscreen-btn');
const backToSettingsBtn = document.getElementById('back-to-settings-btn');
const fontSizeIncreaseBtn = document.getElementById('font-size-increase-btn');
const fontSizeDecreaseBtn = document.getElementById('font-size-decrease-btn');
const readerPagination = document.getElementById('reader-pagination');

// History
const historyBtn = document.getElementById('history-btn');
const historyModal = document.getElementById('history-modal');
const historyCloseBtn = document.getElementById('history-close-btn');
const historyTitle = document.getElementById('history-title');
const historyTabBtns = document.querySelectorAll('.history-tab-btn');
const historyList = document.getElementById('history-list');
const historySearch = document.getElementById('history-search');
const historySort = document.getElementById('history-sort');
const deleteAllHistoryBtn = document.getElementById('delete-all-history-btn');
const vocabToast = document.getElementById('vocab-toast');

// Quiz Elements
const quizBtn = document.getElementById('quiz-btn');
const quizContainer = document.getElementById('quiz-container');
const quizBackBtn = document.getElementById('quiz-back-btn');
const quizTitle = document.getElementById('quiz-title');
const quizScore = document.getElementById('quiz-score');
const quizScoreValue = document.getElementById('quiz-score-value');
const quizProgressCounter = document.getElementById('quiz-progress-counter'); // [修訂四]
const quizSetupScreen = document.getElementById('quiz-setup-screen');
const quizGameScreen = document.getElementById('quiz-game-screen');
const quizTypeSelection = document.getElementById('quiz-type-selection');
const quizScopeSelection = document.getElementById('quiz-scope-selection');
const quizVocabSelectionContainer = document.getElementById('quiz-vocab-selection-container');
const quizVocabSelectionList = document.getElementById('quiz-vocab-selection-list');
const quizSelectedCount = document.getElementById('quiz-selected-count');
const quizSelectAllBtn = document.getElementById('quiz-select-all');
const quizDeselectAllBtn = document.getElementById('quiz-deselect-all');
const quizStartBtn = document.getElementById('quiz-start-btn');
const quizErrorMessage = document.getElementById('quiz-error-message');
const quizQuestionText = document.getElementById('quiz-question-text');
const quizOptionsArea = document.getElementById('quiz-options-area');
const quizFeedbackText = document.getElementById('quiz-feedback-text');
// New Quiz Elements from revision
const quizSentenceSourceContainer = document.getElementById('quiz-sentence-source-container');
const quizSentenceSourceSelection = document.getElementById('quiz-sentence-source-selection');
const quizScopeLabel = document.getElementById('quiz-scope-label');
const quizSentenceArea = document.getElementById('quiz-sentence-area');
const quizSentenceInput = document.getElementById('quiz-sentence-input');
const quizSentenceSubmitBtn = document.getElementById('quiz-sentence-submit');
const quizAiFeedbackArea = document.getElementById('quiz-ai-feedback-area');
const quizAiComment = document.getElementById('quiz-ai-comment');
const quizNextQuestionBtn = document.getElementById('quiz-next-question-btn'); // [修訂一]
// [REVISION] New Quiz DOM selections
const quizMixOptionsContainer = document.getElementById('quiz-mix-options-container');
const quizMixSelection = document.getElementById('quiz-mix-selection');


// === 後端配置 ===
const CLOUDFLARE_WORKER_URL = "https://script.google.com/macros/s/AKfycbw3GLUM12ls3PhST5TkimLZvZwQx2H4RG8g2SbZiMJmuxg3HqsO_d13kPU4AnKpxi2P6A/exec"; // 請確認這是您正確的 GAS URL


// ★★★ 新增：統一處理 Log 顏色的輔助函數 ★★★
function logProviderInfo(dataOrResponse, apiName) {
    let provider = null;
    let debugTrace = null;

    // 1. 判斷資料來源
    if (dataOrResponse._provider_log) {
        // [情況 A] 新版 GAS：從 JSON 本體讀取
        provider = dataOrResponse._provider_log;
        // 如果後端有回傳 trace 陣列，也可在此讀取
        if (Array.isArray(dataOrResponse.trace)) {
            debugTrace = dataOrResponse.trace;
        }
    } else if (dataOrResponse.headers && typeof dataOrResponse.headers.get === 'function') {
        // [情況 B] 舊版/Worker：從 Header 讀取 (保留兼容性)
        provider = dataOrResponse.headers.get('X-Provider-Log');
        const traceStr = dataOrResponse.headers.get('X-Debug-Trace');
        if (traceStr) {
            try { debugTrace = JSON.parse(traceStr); } catch(e) {}
        }
    }

    // 2. 顯示失敗的嘗試 (如果有 Trace)
    if (debugTrace && Array.isArray(debugTrace)) {
        debugTrace.forEach(trace => {
            console.log(`%c[${apiName} Fail] ${trace}`, "color: #ffeb3b; background: #333; padding: 2px 5px;");
        });
    }

    // 3. 顯示成功的調用 (顏色設定)
    if (provider) {
        if (provider.includes("OFFICIAL DEEPSEEK")) {
            // 官方 DeepSeek：橙紅風格
            console.log(`%c🚀 [${apiName}] SUCCESS via ${provider}`, "color: #fff; background: #e64a19; padding: 4px 8px; border-radius: 4px; font-weight: bold;");
        } else {
            // Pollinations 或其他：藍綠風格
            console.log(`%c🌿 [${apiName}] SUCCESS via ${provider}`, "color: #fff; background: #009688; padding: 4px 8px; border-radius: 4px; font-weight: bold;");
        }
    }
}

	

// --- 2. 狀態管理 ---
let state = {
activeMode: 'lookup', 
generateDifficulty: 2,
wordPolishDifficulty: 3,
prosePolishDifficulty: 3,
lookupHistory: JSON.parse(localStorage.getItem('vocabHistory_v3')) || [],
polishingHistory: JSON.parse(localStorage.getItem('polishingHistory_v1')) || [],
activeHistoryTab: 'lookup',
currentResults: null,
currentPageNum: 0,
totalPages: 0,
fontSize: 1.1,
// Quiz State
quizSettings: {
type: 1, // 1: V->D, 2: D->V, 3: S->V, 5: 造句, 4: Mixed
scope: 'all', 
selectedVocabIds: [],
sentenceSource: 'record', // 'record' or 'ai'
aiGeneratedSentences: null, // To store batch fetched sentences
mixedTypes: [1, 2, 3, 5], // [REVISION] Add state for selected mix types
},
quizGame: {
isActive: false,
score: 0,
questions: [],
currentQuestionIndex: -1,
currentQuestion: null,
},
};
let isDragging = false, dragStartX = 0, currentTranslate = 0, startTranslate = 0;

// --- 3. 初始化 ---
const initTheme = () => {
const savedTheme = localStorage.getItem('theme') || 'light-mode';
body.className = savedTheme;
updateThemeIcons(savedTheme);
};

const initFontSize = () => {
state.fontSize = parseFloat(localStorage.getItem('fontSize')) || 1.1;
root.style.setProperty('--reader-font-size', `${state.fontSize}rem`);
};

function initializeDifficultyRating(ratingContainer) {
    if (!ratingContainer) return;
    const dots = ratingContainer.querySelectorAll('.rating-dot');
    let stateKey;
    if (ratingContainer.id.includes('generate')) stateKey = 'generateDifficulty';
    else if (ratingContainer.id.includes('word-polish')) stateKey = 'wordPolishDifficulty';
    else if (ratingContainer.id.includes('prose-polish')) stateKey = 'prosePolishDifficulty';
    else return;

    const updateDots = () => {
        dots.forEach(dot => {
            dot.classList.toggle('selected', parseInt(dot.dataset.value) <= state[stateKey]);
        });
    };

    dots.forEach(dot => {
    dot.addEventListener('click', () => {
        const maxLimit = (stateKey === 'generateDifficulty') ? 3 : 5;  // 新增：根據模式動態設定上限
        state[stateKey] = Math.min(maxLimit, parseInt(dot.dataset.value));
        ratingContainer.dataset.rating = state[stateKey];
        updateDots();
    });
    dot.addEventListener('mouseover', () => {
        const hoverValue = parseInt(dot.dataset.value);
        dots.forEach(d => d.classList.toggle('selected', parseInt(d.dataset.value) <= hoverValue));
    });
});

ratingContainer.addEventListener('mouseleave', updateDots);
updateDots();

    ratingContainer.addEventListener('mouseleave', updateDots);
    updateDots();
}

initTheme();
initFontSize();
initializeDifficultyRating(generateDifficultyRating);
initializeDifficultyRating(wordPolishDifficultyRating);
initializeDifficultyRating(prosePolishDifficultyRating);

// --- 4. 事件監聽器 ---
themeSwitchers.forEach(switcher => switcher.addEventListener('click', toggleTheme));

modeBtns.forEach(btn => {
btn.addEventListener('click', () => switchMode(btn.dataset.mode));
});

submitBtn.addEventListener('click', handleSubmit);

fullscreenBtn.addEventListener('click', toggleFullscreen);
backToSettingsBtn.addEventListener('click', () => {
if (body.classList.contains('fullscreen-mode')) {
toggleFullscreen();
}
switchToSettingsView();
});

fontSizeIncreaseBtn.addEventListener('click', () => changeFontSize(0.1));
fontSizeDecreaseBtn.addEventListener('click', () => changeFontSize(-0.1));

// History Event Listeners
historyBtn.addEventListener('click', showHistory);
historyCloseBtn.addEventListener('click', hideHistory);
deleteAllHistoryBtn.addEventListener('click', deleteAllHistoryForCurrentTab);
historyModal.addEventListener('click', (e) => { if (e.target === historyModal) hideHistory(); });
historyList.addEventListener('click', handleHistoryListClick);
historySearch.addEventListener('input', renderHistory);
historySort.addEventListener('change', renderHistory);
historyTabBtns.forEach(btn => btn.addEventListener('click', switchHistoryTab));

bookContainer.addEventListener('mousedown', dragStart);
bookContainer.addEventListener('touchstart', dragStart, { passive: true });
document.addEventListener('mousemove', dragMove);
document.addEventListener('touchmove', dragMove, { passive: true });
document.addEventListener('mouseup', dragEnd);
document.addEventListener('touchend', dragEnd);

readingSection.addEventListener('click', handleReaderClick);

// Quiz Event Listeners
quizBtn.addEventListener('click', showQuiz);
quizBackBtn.addEventListener('click', hideQuiz);
quizTypeSelection.addEventListener('click', handleQuizTypeSelect);
quizScopeSelection.addEventListener('click', handleQuizScopeSelect);
quizVocabSelectionList.addEventListener('click', handleQuizVocabItemSelect);
quizSelectAllBtn.addEventListener('click', () => selectAllQuizVocab(true));
quizDeselectAllBtn.addEventListener('click', () => selectAllQuizVocab(false));
quizStartBtn.addEventListener('click', startQuiz);
quizOptionsArea.addEventListener('click', handleQuizAnswer);
quizSentenceSourceSelection.addEventListener('click', handleSentenceSourceSelect);
quizSentenceSubmitBtn.addEventListener('click', handleSentenceSubmit);
quizNextQuestionBtn.addEventListener('click', displayNextQuizQuestion); // [修訂一]
quizMixSelection.addEventListener('click', handleQuizMixSelect); // [REVISION]


// --- 5. 核心功能函式 ---

function toggleTheme() {
const newTheme = body.classList.contains('light-mode') ? 'dark-mode' : 'light-mode';
body.className = newTheme;
localStorage.setItem('theme', newTheme);
updateThemeIcons(newTheme);

if (!readingSection.classList.contains('hidden')) {
if (!body.classList.contains('fullscreen-mode')) {
toggleFullscreen();
} else if (state.currentResults) {
setTimeout(() => displayResultsAsBook(state.currentResults), 50);
}
}
}

function updateThemeIcons(theme) {
themeSwitchers.forEach(switcher => {
const lightIcon = switcher.querySelector('.icon-theme-light');
const darkIcon = switcher.querySelector('.icon-theme-dark');
if(lightIcon && darkIcon) {
lightIcon.classList.toggle('hidden', theme === 'dark-mode');
darkIcon.classList.toggle('hidden', theme === 'light-mode');
}
});
}

function switchMode(newMode) {
state.activeMode = newMode;
modeBtns.forEach(btn => {
btn.classList.toggle('active', btn.dataset.mode === newMode);
});

lookupForm.classList.add('hidden');
generateForm.classList.add('hidden');
wordPolishForm.classList.add('hidden');
prosePolishForm.classList.add('hidden');

let btnText = '';
if (newMode === 'lookup') {
lookupForm.classList.remove('hidden');
btnText = '開始查考';
} else if (newMode === 'generate') {
generateForm.classList.remove('hidden');
btnText = '隨機尋詞';
} else if (newMode === 'word-polish'){
wordPolishForm.classList.remove('hidden');
btnText = '開始潤色';
} else if (newMode === 'prose-polish'){
prosePolishForm.classList.remove('hidden');
btnText = '開始潤色';
}
submitBtnText.textContent = btnText;
errorMessage.style.display = 'none';
}

function setLoading(isLoading, element = submitBtn, text = '執行中...') {
    element.disabled = isLoading;
    const btnTextElement = element.querySelector('.btn-text');

    if (!btnTextElement) return;

    const originalText = btnTextElement.textContent;
    if (!element.dataset.originalText) {
        element.dataset.originalText = originalText;
    }

    const existingLoader = element.querySelector('.loader');

    if (isLoading) {
        btnTextElement.textContent = text;
        if (!existingLoader) {
            const loader = document.createElement('div');
            loader.className = 'loader';
            element.insertBefore(loader, btnTextElement);
        }
    } else {
        if (existingLoader) existingLoader.remove();
        btnTextElement.textContent = element.dataset.originalText || 'Submit';
    }
}


function showError(message) {
errorMessage.textContent = message;
errorMessage.style.display = 'block';
}

async function handleSubmit(e) {
    e.preventDefault();
    errorMessage.style.display = 'none';

    try {
        if (state.activeMode === 'word-polish') {
            const text = wordPolishTextarea.value.trim();
            if (!text) {
                showError('請輸入需要潤色「詞語」的內容。');
                return;
            }
            setLoading(true, submitBtn, '潤色中...');
            const result = await fetchWordPolishedText(text, state.wordPolishDifficulty);
            if (result) {
                addToPolishingHistory(result);
                state.currentResults = [result];
                state.currentPageNum = 0;
                displayResultsAsBook(state.currentResults);
                switchToReaderView();
            }
        } else if (state.activeMode === 'prose-polish') {
            const text = prosePolishTextarea.value.trim();
            if (!text) {
                showError('請輸入需要潤色「文句」的內容。');
                return;
            }
            setLoading(true, submitBtn, '潤色中...');
            const result = await fetchProsePolishedText(text, state.prosePolishDifficulty);
            if (result) {
                addToPolishingHistory(result);
                state.currentResults = [result];
                state.currentPageNum = 0;
                displayResultsAsBook(state.currentResults);
                switchToReaderView();
            }
        } else {
            let options = {};
            if (state.activeMode === 'lookup') {
                const word = lookupWordInput.value.trim();
                if (!word) {
                    showError('請輸入要查找的詞彙。');
                    return;
                }
                options = { mode: 'lookup', query: word };
                setLoading(true, submitBtn, '查找中...');
            } else { // 'generate' mode
                options = {
                    mode: 'generate',
                    difficulty: state.generateDifficulty,
                    count: parseInt(wordCountSelect.value),
                    topic: promptTextarea.value.trim()
                };
                setLoading(true, submitBtn, '生成中...');
            }

            const results = await fetchVocabulary(options);
            if (results && results.length > 0) {
                // [修訂] 移除此處的 addToLookupHistory(results);
                state.currentResults = results;
                state.currentPageNum = 0;
                displayResultsAsBook(results);
                switchToReaderView();
            }
        }
    } catch (error) {
        console.error('Submit process error:', error);
        showError(`處理失敗: ${error.message}`);
    } finally {
        setLoading(false, submitBtn);
        switchMode(state.activeMode);
    }
}
  
async function fetchProsePolishedText(text, difficulty) {
const systemPrompt = `你是一位專業的中文文學編輯，擅長將平實的文字改寫得更具文采和深度。
你的任務是要在維持原文字數絕不減少的大前提下，根據使用者提供的文本，進行「文句潤色」，並將原文與潤色後的文句進行配對。

核心規則：
1. 【嚴守原意】：潤色後的文句必須保持原文的核心資訊和敘事框架。
2. 【風格調整】：根據「風格」等級（1-5）調整文采。等級越高，意象越豐富，但用詞不要浮誇，不要套語，例如「心如刀割」，必須妥帖自然，平實動人，富有哲理和留白空間，而且不可過份放大物件的細節。
3. 【段落對應】：你必須將原文的每個段落，與其對應的潤色後段落配對。
- 如果一個段落被潤色，則一對一配對。
- 如果原文中的【多個連續段落】被合併為一個，將它們（在 "original" 欄位中用 \\n 分隔）配對到【一個】潤色後的段落。
- 如果原文中的一個段落被拆分為多個，將它配對到【多個】潤色後的段落（在 "polished" 欄位中用 \\n 分隔）。
4. 【標示改動】：在潤色後的段落("polished" 欄位)中，用 \`<mark class="mark-polished">\` 標籤包裹你認為最關鍵、最能體現潤色效果的【一個或多個完整句子】。然後，在對應的原文段落("original" 欄位)中，找到這些句子【改寫前】的樣貌，並用 \`<mark class="mark-original">\` 標籤包裹它們。這兩組標籤應形成一對一的參照。
5. 【JSON 格式輸出】：你的回傳內容【必須】是單一的 JSON 物件，不含任何 markdown 語法。所有文字都必須是繁體中文。
6. 為了確保每次都能生成全新的潤色結果，請將此唯一請求 ID 納入考量：${Date.now()}。

JSON 物件必須包含一個 "comparison" key，其值為一個物件陣列。每個物件代表一個配對，包含：
a. "original": (string) 一個或多個原文段落，以 '\\n' 分隔，並可能包含 \`<mark class="mark-original">\` 標籤。
b. "polished": (string) 一個或多個對應的潤色後段落，以 '\\n' 分隔，並包含 \`<mark class="mark-polished">\` 標籤。

風格等級：${difficulty}
原文：
---
${text}
---

JSON 格式範例:
{
"comparison": [
{
"original": "我今天走在公園裡。\\n<mark class=\\"mark-original\\">看到一朵很美的花。</mark>",
"polished": "今日信步於公園，<mark class=\\"mark-polished\\">與一朵絕美之花不期而遇。</mark>"
},
{
"original": "<mark class=\\"mark-original\\">我覺得很開心。</mark>",
"polished": "<mark class=\\"mark-polished\\">見此景，心中漾起一陣難以言喻的喜悅。</mark>"
}
]
}`;
 try {
        const response = await fetch(CLOUDFLARE_WORKER_URL, {
            method: 'POST',
            // GAS Web App 不需要 Authorization Header
            body: JSON.stringify({
                model: "gemini",
                messages: [{ role: "user", content: systemPrompt }],
                response_format: { type: "json_object" },
                max_tokens: 8192,
                temperature: 1
            })
        });

        if (!response.ok) throw new Error(`API 請求失敗，狀態碼：${response.status}`);
        const data = await response.json();

        // ★★★ 調用美化 Log 函數 ★★★
        logProviderInfo(data, "ProsePolish");

        // 錯誤檢查
        if (data.error) {
            console.error('後端返回錯誤:', data.error);
            throw new Error(`生成失敗: ${data.error}`);
        }

        const content = parseJsonFromResponse(data.choices?.[0]?.message?.content);

        if (!content || !Array.isArray(content.comparison) || content.comparison.length === 0) {
            throw new Error("API 未返回有效的 comparison 陣列或格式錯誤。");
        }

        const polishedTextWithMarks = content.comparison.map(p => p.polished).join('\n\n');
        const polishedTextClean = polishedTextWithMarks.replace(/<mark.*?>/g, '').replace(/<\/mark>/g, '');

        return {
            type: 'prose-polish-result',
            vocab: '文句潤色結果',
            originalText: text,
            polishedText: polishedTextClean,
            comparisonData: content.comparison,
            generatedDate: new Date().toISOString()
        };

    } catch (error) {
        console.error("API Error (Prose Polish):", error);
        showError(`文句潤色失敗: ${error.message}`);
        return null;
    }
}


async function fetchWordPolishedText(text, difficulty) {
const systemPrompt = `你是一位專業的中文編輯。你的任務是潤飾使用者提供的文章，但【絕對不能】改變原文的核心意義。請根據指定的難度（1-5），將文中的部分【兩字或四字詞彙】替換成更典雅、精準或富有文學性的同義詞。

重要指示:
1. 保持原文的結構、語氣和核心意義不變。盡量找最多的詞彙去替換，以一千字文章為例，起碼都需要找二十個不同的詞語去替換原文的詞語。
2. 僅替換詞彙，不要增刪句子或改變句式，必須保持段落數量一致。
3. 難度為 1-2 時，使用常用但更精確的詞語。難度為 3 時，使用書面語或成語。難度為 4-5 時，可使用較為冷僻的詞彙，但文體仍必須維持為白話，不要文白夾雜。難度越高，替換的詞匯數量愈多。
4. 你的回傳內容必須是【單一的 JSON 物件】，絕對不要包含任何 markdown 語法或額外說明。
5. 所有文字都必須是繁體中文。
6. JSON 物件必須包含兩個 keys:
a. "polishedText": (string) 包含潤飾後的完整全文。
b. "changes": (array of objects) 一個陣列，列出所有被替換的詞彙。每個物件包含 "original" (潤飾前的詞) 和 "polished" (潤飾後的詞)。
- 【重要】"changes" 陣列中的詞彙【必須】是兩個字或四個字。
7. 為了確保每次都能生成全新的潤色結果，請將此唯一請求 ID 納入考量：${Date.now()}。

潤飾難度: ${difficulty}
原文:
---
${text}
---

JSON 格式範例:
{
"polishedText": "她芳齡幾何，無人知曉，僅知其風姿綽約，引人遐思。",
"changes": [
{ "original": "年紀", "polished": "芳齡" },
{ "original": "樣子", "polished": "風姿" },
{ "original": "美麗", "polished": "綽約" }
]
}`;
 try {
        const response = await fetch(CLOUDFLARE_WORKER_URL, {
            method: 'POST',
            // GAS Web App 不需要 Authorization Header
            body: JSON.stringify({
                model: "gemini",
                messages: [{ role: "user", content: systemPrompt }],
                response_format: { type: "json_object" },
                max_tokens: 8192,
                temperature: 0.8
            })
        });

        if (!response.ok) throw new Error(`API 請求失敗，狀態碼：${response.status}`);
        const data = await response.json();

        // ★★★ 調用美化 Log 函數 ★★★
        logProviderInfo(data, "WordPolish");

        // 錯誤檢查
        if (data.error) {
            console.error('後端返回錯誤:', data.error);
            throw new Error(`生成失敗: ${data.error}`);
        }

        const content = parseJsonFromResponse(data.choices?.[0]?.message?.content);

        if (!content || !content.polishedText || !Array.isArray(content.changes)) {
            throw new Error("API 未返回有效的潤色內容或格式錯誤。");
        }

        return {
            type: 'word-polish-result',
            vocab: '詞彙潤色結果',
            originalText: text,
            polishedText: content.polishedText,
            changes: content.changes,
            generatedDate: new Date().toISOString()
        };

    } catch (error) {
        console.error("API Error (Word Polish):", error);
        showError(`詞彙潤色失敗: ${error.message}`);
        return null;
    }
}

async function fetchVocabulary(options) {
    const { mode, query, difficulty, count, topic } = options;
    let systemPrompt;
    
    // 定義統一的 JSON 輸出格式指令
    const jsonFormatInstruction = `{
    "results": [
        {
            "vocab": "詞彙",
            "definition": "對該詞彙的精闢中文解釋",
            "examples": [
                "來自真實中文文學作品的例句一",
                "來自真實中文文學作品的例句二",
                "來自真實中文文學作品的例句三",
                "來自真實中文文學作品的例句四",
                "來自真實中文文學作品的例句五"
            ]
        }
    ]
    }`;

    // --- 1. 建構 Prompt (根據模式) ---

    if (mode === 'lookup') {
        // [查考模式]
        systemPrompt = `你是一個詞彙學家與文學評論家。你的任務是為使用者提供的特定詞彙，提供詳細的解釋和文學例句。
使用者指定的詞彙: "${query}"
重要指示:
1. 你必須提供該詞彙的精確解釋。
2. 你必須提供五句具高度文學性的例句，即例句必須有文學的留白，予人有解讀的空間。每一句都必須引用自【真實世界中繁體中文作家的文學作品】，但【絕對不能】標示作家或作品名稱。
3. 你的回傳內容必須嚴格遵循以下的 JSON 格式，不要包含任何 markdown 語法或額外說明。
4. 所有文字都必須是繁體中文。
5. 詞彙要白話一點，不要古典用詞。
JSON 格式:
${jsonFormatInstruction}`;

    } else { 
        // [生成模式] (漫遊詞海)
        
        // 檢查是否有未使用的預定義詞彙
        const usedVocabs = new Set(state.lookupHistory.map(item => item.vocab));
        const availablePredefinedVocabs = PREDEFINED_VOCABS.filter(vocab => !usedVocabs.has(vocab));
        
        const historyVocabs = state.lookupHistory.map(item => item.vocab).join(', ');
        
        // 判斷：只有在「沒有指定主題」且「還有預定義詞彙」時，才使用本地預定義詞庫
        let shouldUsePredefined = !topic && availablePredefinedVocabs.length > 0;
        
        if (shouldUsePredefined) {
            // [生成模式 - A] 使用預定義詞彙
            const selectedVocabs = [];
            const shuffleArray = [...availablePredefinedVocabs];
            for (let i = shuffleArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffleArray[i], shuffleArray[j]] = [shuffleArray[j], shuffleArray[i]];
            }
            selectedVocabs.push(...shuffleArray.slice(0, Math.min(count, availablePredefinedVocabs.length)));
            
            const selectedVocabsStr = selectedVocabs.join('、');
            
            systemPrompt = `你是一個詞彙學家與文學評論家。你的任務是為以下指定的繁體中文詞彙，提供詳細的解釋和文學例句。
使用者指定的詞彙列表: "${selectedVocabsStr}"
重要指示:
1. 你必須為列表中的每一個詞彙提供精確解釋。
2. 你必須提供五句具高度文學性的例句，即例句必須有文學的留白，予人有解讀的空間。每一句都必須引用自【真實世界中繁體中文作家的文學作品】，但【絕對不能】標示作家或作品名稱。
3. 你的回傳內容必須嚴格遵循以下的 JSON 格式，不要包含任何 markdown 語法或額外說明。
4. 所有文字都必須是繁體中文。
5. 詞彙要白話一點，不要古典用詞。
JSON 格式 (results 陣列中應有 ${selectedVocabs.length} 個物件，對應每個指定的詞彙):
${jsonFormatInstruction}`;

        } else {
            // [生成模式 - B] AI 全新生成 (有主題 或 預定義用盡)
            
            let constraints = "";
            let topicDirectives = "";

            if (topic) {
                // 有主題：專注於主題相關性
                topicDirectives = `使用者指定主題：【${topic}】。
                請務必生成與「${topic}」這個概念高度相關、能精準描述、修飾或延伸該主題的詞彙。
                詞彙與主題的關聯性必須強烈且直觀。`;
                constraints = "生成的詞彙必須與指定主題有強烈的語意關聯。";
            } else {
                // 無主題 (且預定義用盡)：隨機生成，但偏向敘事抒情
                topicDirectives = "請隨機選擇一個具文學性的主題。";
                constraints = "生成詞彙不要以「自然景象」為相關（例如日、月、星、霧），須生成敘事抒情文會運用的詞彙。不可生成隱含任何比喻的詞彙。";
            }

            systemPrompt = `你是一個詞彙學家與文學評論家。你的任務是生成富有文學性的繁體中文詞彙，每個詞只有兩個字或四個字。
${topicDirectives}

使用者設定:
- 難度（1-3顆星）: ${difficulty} (難度越高，用詞越精確、書面或罕見)
- 生成數量: ${count}

重要指示:
1. ${constraints}
2. 【嚴禁自創新詞】：你生成的每一個詞彙【必須】是真實存在、且在現代繁體中文書面語中實際被使用的詞語。嚴禁自行組合字元創造新詞。
3. 為每個生成的詞彙提供精確的解釋、以及五句文學例句。例句必須有文學的留白，予人有解讀的空間。
4. 每一句例句都必須引用自【真實世界中繁體中文作家的文學作品】，但【絕對不能】標示作家或作品名稱。
5. 生成的詞彙【絕對不能】重複。【絕對不能生成以下任何已知詞彙，否則此生成視為無效】：${historyVocabs}。
6. 你的回傳內容必須嚴格遵循以下的 JSON 格式，不要包含任何 markdown 語法或額外說明。
7. 所有文字都必須是繁體中文。
8. 為了確保每次都能生成全新的內容，請將此唯一請求 ID 納入考量：${Date.now()}。

JSON 格式 (results 陣列中應有 ${count} 個物件):
${jsonFormatInstruction}`;
        }
    }

    // --- 2. 發送 API 請求 (透過 GAS 後端) ---

    try {
        // [情境 1 & 2] 查考模式 或 預定義生成模式 (不需要前端重試邏輯)
        if (mode === 'lookup' || (mode === 'generate' && !topic && PREDEFINED_VOCABS.filter(v => !new Set(state.lookupHistory.map(i => i.vocab)).has(v)).length > 0)) {
            
            const response = await fetch(CLOUDFLARE_WORKER_URL, {
                method: 'POST',
                body: JSON.stringify({
                    model: "gemini",
                    messages: [{ role: "user", content: systemPrompt }],
                    response_format: { type: "json_object" },
                    max_tokens: 8192,
                    temperature: 1
                })
            });

            if (!response.ok) throw new Error(`API 請求失敗，狀態碼：${response.status}`);
            const data = await response.json();

            // ★★★ Log 資訊 ★★★
            logProviderInfo(data, mode === 'lookup' ? "VocabLookup" : "VocabPredefined");

            if (data.error) throw new Error(`生成失敗: ${data.error}`);
            if (!data.choices?.[0]?.message?.content) throw new Error("API 回應格式不正確。");

            // 檢查內容是否為有效 JSON 字符串，嘗試修復常見錯誤
            let content = data.choices[0].message.content;
            
            // 嘗試修復未終止的字符串（如 "那 沒有結束引號）
            if (content.includes('"examples"')) {
                // 修復未終止的字符串引號
                content = content.replace(
                    /"examples"\s*:\s*\[(.*?)\]/gs,
                    (match, examplesContent) => {
                        // 將每個未結束的字符串補上引號
                        const fixedExamples = examplesContent.replace(
                            /"([^"\n\r]*)(?=\s*,?\s*[\}\]])/g,
                            (strMatch, strContent) => {
                                // 如果匹配到的字符串沒有結束引號，補上
                                if (!strMatch.endsWith('"')) {
                                    return `"${strContent}"`;
                                }
                                return strMatch;
                            }
                        );
                        return `"examples":[${fixedExamples}]`;
                    }
                );
                
                // 修復缺少逗號的情況
                content = content.replace(
                    /"(\s*)(?=\])/g,
                    '"$1'
                );
            }
            
            const parsedData = parseJsonFromResponse(content);

            if (!parsedData || !parsedData.results || !Array.isArray(parsedData.results) || parsedData.results.length === 0) {
                // 如果解析失敗，嘗試從原始內容中提取部分數據
                console.warn("API JSON 解析失敗，嘗試提取部分數據...");
                
                // 嘗試提取詞彙和定義
                const vocabMatch = content.match(/"vocab"\s*:\s*"([^"]+)"/);
                const definitionMatch = content.match(/"definition"\s*:\s*"([^"]+)"/);
                
                if (vocabMatch && definitionMatch) {
                    // 嘗試提取例句
                    const examples = [];
                    const exampleMatches = content.match(/"examples"\s*:\s*\[(.*?)\]/s);
                    
                    if (exampleMatches) {
                        const exampleText = exampleMatches[1];
                        // 嘗試找到所有被引號包圍的字符串
                        const quoteMatches = exampleText.match(/"([^"]+)"/g);
                        if (quoteMatches) {
                            quoteMatches.forEach(match => {
                                examples.push(match.replace(/"/g, ''));
                            });
                        }
                    }
                    
                    // 確保至少有3個例句
                    while (examples.length < 3) {
                        examples.push("例句資料不完整");
                    }
                    
                    // 返回修復後的數據
                    const fixedResults = [{
                        vocab: vocabMatch[1],
                        definition: definitionMatch[1],
                        examples: examples.slice(0, 5)
                    }];
                    
                    // 資料後處理與驗證
                    fixedResults.forEach(item => {
                        while(item.examples.length < 5) {
                            item.examples.push(`[缺少例句]`);
                        }
                        item.examples = item.examples.slice(0, 5);
                        item.type = 'vocab';
                        const timestamp = new Date().toISOString();
                        item.generatedDate = timestamp;
                        item.id = `${timestamp}-${item.vocab}`;
                    });
                    
                    return fixedResults;
                }
                
                throw new Error("API 回應的 JSON 內容不完整或格式錯誤，且無法修復。");
            }

            // 資料後處理與驗證
            parsedData.results.forEach(item => {
                if (!item.vocab || !item.definition || !item.examples || !Array.isArray(item.examples)) {
                    console.warn(`詞彙 "${item.vocab || '未知'}" 的資料不完整或格式錯誤，將被過濾。`);
                    return;
                }
                while(item.examples.length < 5) {
                    item.examples.push(`[缺少例句]`);
                }
                item.examples = item.examples.slice(0, 5);
                item.type = 'vocab';
                const timestamp = new Date().toISOString();
                item.generatedDate = timestamp;
                item.id = `${timestamp}-${item.vocab}`;
            });

            const validResults = parsedData.results.filter(item => item.vocab && item.definition && item.examples);
            if(validResults.length === 0) {
                throw new Error("API 回應的所有詞彙資料均不完整。");
            }
            return validResults;

        } else { 
            // [情境 3] AI 全新生成模式 (需要前端重試邏輯以避免重複)
            
            let maxRetries = 30; // 前端重試次數 (針對內容重複)
            let results = null;

            while (maxRetries > 0) {
                const response = await fetch(CLOUDFLARE_WORKER_URL, {
                    method: 'POST',
                    body: JSON.stringify({
                        model: "gemini",
                        messages: [{ role: "user", content: systemPrompt }],
                        response_format: { type: "json_object" },
                        max_tokens: 4096,
                        temperature: 1.2 // 提高溫度以增加多樣性
                    })
                });

                if (!response.ok) throw new Error(`API 請求失敗，狀態碼：${response.status}`);
                const data = await response.json();

                // ★★★ Log 資訊 ★★★
                logProviderInfo(data, `VocabGenerate(Try:${31-maxRetries})`);

                if (data.error) {
                    // 後端錯誤 (如 key 耗盡)，記錄並重試
                    console.warn(`生成失敗: ${data.error}，剩餘重試次數：${--maxRetries}`);
                    continue;
                }

                if (!data.choices?.[0]?.message?.content) throw new Error("API 回應格式不正確。");
                
                // 嘗試修復 JSON 內容
                let content = data.choices[0].message.content;
                if (content.includes('"examples"')) {
                    content = content.replace(
                        /"examples"\s*:\s*\[(.*?)\]/gs,
                        (match, examplesContent) => {
                            const fixedExamples = examplesContent.replace(
                                /"([^"\n\r]*)(?=\s*,?\s*[\}\]])/g,
                                (strMatch, strContent) => {
                                    if (!strMatch.endsWith('"')) {
                                        return `"${strContent}"`;
                                    }
                                    return strMatch;
                                }
                            );
                            return `"examples":[${fixedExamples}]`;
                        }
                    );
                }
                
                const parsedData = parseJsonFromResponse(content);
                
                if (!parsedData.results || !Array.isArray(parsedData.results) || parsedData.results.length === 0) {
                    // 格式錯誤，重試
                    console.warn("API JSON 格式錯誤，重試中...");
                    maxRetries--;
                    continue;
                }

                // 資料驗證與補齊
                parsedData.results.forEach(item => {
                    if (!item.vocab || !item.definition || !item.examples || !Array.isArray(item.examples)) {
                        return;
                    }
                    while(item.examples.length < 5) item.examples.push(`[缺少例句]`);
                    item.examples = item.examples.slice(0, 5);
                    item.type = 'vocab';
                    const timestamp = new Date().toISOString();
                    item.generatedDate = timestamp;
                    item.id = `${timestamp}-${item.vocab}`;
                });

                let validResults = parsedData.results.filter(item => item.vocab && item.definition && item.examples);

                // --- 關鍵：前端去重邏輯 ---
                const historyVocabsSet = new Set(state.lookupHistory.map(item => item.vocab));
                const duplicates = validResults.filter(result => historyVocabsSet.has(result.vocab));
                
                if (duplicates.length > 0) {
                    console.warn(`生成結果有 ${duplicates.length} 個重複，剩餘重試次數：${--maxRetries}`);
                    continue; // 有重複，重試
                }

                if (validResults.length === 0) {
                    throw new Error("API 回應的所有詞彙資料均不完整。");
                }

                results = validResults; // 成功獲取不重複資料
                break; // 跳出迴圈
            }

            // Fallback 邏輯 (如果重試全失敗)
            if (!results) {
                console.error("重試達上限，啟用 fallback 過濾重複詞彙。");
                
                // 最後一次嘗試呼叫 (不檢查重複，只求有結果)
                const fallbackResponse = await fetch(CLOUDFLARE_WORKER_URL, {
                    method: 'POST',
                    body: JSON.stringify({
                        model: "gemini",
                        messages: [{ role: "user", content: systemPrompt }],
                        response_format: { type: "json_object" },
                        max_tokens: 4096,
                        temperature: 1.2
                    })
                });

                if (!fallbackResponse.ok) throw new Error(`Fallback API 請求失敗，狀態碼：${fallbackResponse.status}`);
                const fallbackData = await fallbackResponse.json();
                
                logProviderInfo(fallbackData, "VocabFallback");

                if (fallbackData.error) throw new Error(`生成失敗: ${fallbackData.error}`);

                // 嘗試修復 fallback 內容
                let fallbackContent = fallbackData.choices?.[0]?.message?.content || '';
                if (fallbackContent.includes('"examples"')) {
                    fallbackContent = fallbackContent.replace(
                        /"examples"\s*:\s*\[(.*?)\]/gs,
                        (match, examplesContent) => {
                            const fixedExamples = examplesContent.replace(
                                /"([^"\n\r]*)(?=\s*,?\s*[\}\]])/g,
                                (strMatch, strContent) => {
                                    if (!strMatch.endsWith('"')) {
                                        return `"${strContent}"`;
                                    }
                                    return strMatch;
                                }
                            );
                            return `"examples":[${fixedExamples}]`;
                        }
                    );
                }
                
                const fallbackParsed = parseJsonFromResponse(fallbackContent);
                
                if (!fallbackParsed.results || !Array.isArray(fallbackParsed.results)) {
                    throw new Error("Fallback 回應格式錯誤。");
                }

                fallbackParsed.results.forEach(item => {
                    if (!item.vocab || !item.definition || !item.examples) return;
                    while(item.examples.length < 5) item.examples.push(`[缺少例句]`);
                    item.examples = item.examples.slice(0, 5);
                    item.type = 'vocab';
                    const timestamp = new Date().toISOString();
                    item.generatedDate = timestamp;
                    item.id = `${timestamp}-${item.vocab}`;
                });

                let fallbackValid = fallbackParsed.results.filter(item => item.vocab && item.definition && item.examples);
                
                // 盡力過濾，如果過濾後沒剩半個，那就報錯
                const historyVocabsSet = new Set(state.lookupHistory.map(item => item.vocab));
                results = fallbackValid.filter(result => !historyVocabsSet.has(result.vocab));
                
                if (results.length === 0) {
                    throw new Error("Fallback 後仍無有效不重複詞彙，請稍後重試。");
                }
                console.warn(`Fallback 過濾後剩 ${results.length} 個不重複詞彙。`);
            }
            return results;
        }

    } catch(error) {
        console.error("API Error (Vocab):", error);
        if (error instanceof SyntaxError) {
            showError("API 回傳格式錯誤，無法解析。請重試。");
        } else {
            showError(`獲取資料時發生錯誤: ${error.message}`);
        }
        return null;
    }
}

function addToLookupHistory(results) {
if (!results || !Array.isArray(results)) return;
const newVocabs = results.map(r => r.vocab);
state.lookupHistory = state.lookupHistory.filter(item => !newVocabs.includes(item.vocab));
state.lookupHistory.unshift(...results);
if (state.lookupHistory.length > 100) {
state.lookupHistory = state.lookupHistory.slice(0, 100);
}
localStorage.setItem('vocabHistory_v3', JSON.stringify(state.lookupHistory));
}

function addToPolishingHistory(result) {
if (!result) return;
const defaultTitle = `未命名篇章 ${new Date().toLocaleString('zh-TW', { hour12: false })}`;
result.title = defaultTitle;
result.id = result.generatedDate;

state.polishingHistory.unshift(result);

if (state.polishingHistory.length > 50) {
state.polishingHistory = state.polishingHistory.slice(0, 50);
}
localStorage.setItem('polishingHistory_v1', JSON.stringify(state.polishingHistory));
showToast('潤色結果已儲存', 'success');
}


function switchToReaderView() {
settingsSection.classList.add('hidden');
readingSection.classList.remove('hidden');
if (!body.classList.contains('fullscreen-mode')) {
toggleFullscreen();
}
}

function switchToSettingsView() {
readingSection.classList.add('hidden');
settingsSection.classList.remove('hidden');
state.currentResults = null;
state.totalPages = 0;
updatePaginationDisplay();
}

function toggleFullscreen() {
body.classList.toggle('fullscreen-mode');
setTimeout(() => {
if (state.currentResults) {
displayResultsAsBook(state.currentResults);
}
}, 100);
}

function changeFontSize(amount) {
const newSize = Math.max(0.8, Math.min(1.8, state.fontSize + amount));
state.fontSize = Math.round(newSize * 10) / 10;
localStorage.setItem('fontSize', state.fontSize);
root.style.setProperty('--reader-font-size', `${state.fontSize}rem`);
if (state.currentResults) {
displayResultsAsBook(state.currentResults);
}
}

// --- 6. 結果顯示與翻頁 ---
function displayResultsAsBook(results) {
    const currentPageBeforeRepagination = state.currentPageNum;
    book.innerHTML = '';
    book.style.transition = 'none';

    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function applyHighlights(text, changes, type) {
        if (!changes || changes.length === 0) return text;
        let highlightedText = text;

        changes.forEach(change => {
            const wordToFind = type === 'original' ? change.original : change.polished;
            const className = type === 'original' ? 'mark-original' : 'mark-polished';

            if (highlightedText.includes(wordToFind)) {
                const regex = new RegExp(escapeRegExp(wordToFind) + '(?![^<]*>)', 'g');
                highlightedText = highlightedText.replace(regex, `<mark class="${className}">${wordToFind}</mark>`);
            }
        });
        return highlightedText;
    }

    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return '';
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }


    setTimeout(() => {
        if (!bookContainer.clientWidth) return;
        state.totalPages = results.length;

        results.forEach((item, resultIndex) => {
            const pageElement = document.createElement('div');
            pageElement.className = 'page';
            let contentHTML = '';
            const pageTitle = item.title || item.vocab;

            let viewModeClass = '';
            if (item.type === 'word-polish-result') {
                viewModeClass = 'word-polish-view';
            } else if (item.type === 'prose-polish-result') {
                viewModeClass = 'prose-polish-view';
            }

            if (item.type === 'word-polish-result' || item.type === 'prose-polish-result') {
                let comparisonHTML = '';
                let fullPolishedHtmlWithMarks = '';
                const encodedPolishedTextClean = escapeHtml(item.polishedText);

                if (item.type === 'prose-polish-result') {
                    comparisonHTML = item.comparisonData.map((pair, i) => {
                        const originalHTML = (pair.original || '').replace(/\n/g, '<br>');
                        const polishedHTML = (pair.polished || '').replace(/\n/g, '<br>');

                        return `
<div class="comparison-pair">
<div>
<div class="para-marker">原文區塊 ${i + 1}</div>
<div class="original-para">${originalHTML.trim() ? originalHTML : '&nbsp;'}</div>
</div>
<div>
<div class="para-marker">潤色後區塊 ${i + 1}</div>
<div class="polished-para">${polishedHTML.trim() ? polishedHTML : '&nbsp;'}</div>
</div>
</div>
`;
                    }).join('');

                    fullPolishedHtmlWithMarks = item.comparisonData.map(p => p.polished).join('\n\n');

                } else { // 'word-polish'
                    const originalParas = item.originalText.split('\n').filter(p => p.trim() !== '');
                    const polishedParas = item.polishedText.split('\n').filter(p => p.trim() !== '');
                    const loopCount = Math.max(originalParas.length, polishedParas.length);

                    for (let i = 0; i < loopCount; i++) {
                        const originalP = originalParas[i] || '';
                        const polishedP = polishedParas[i] || '';
                        const highlightedOriginalP = applyHighlights(escapeHtml(originalP), item.changes, 'original');
                        const highlightedPolishedP = applyHighlights(escapeHtml(polishedP), item.changes, 'polished');

                        comparisonHTML += `
<div class="comparison-pair">
<div>
<div class="para-marker">原文段落 ${i + 1}</div>
<div class="original-para">${highlightedOriginalP.trim() ? highlightedOriginalP : '&nbsp;'}</div>
</div>
<div>
<div class="para-marker">潤色後段落 ${i + 1}</div>
<div class="polished-para">${highlightedPolishedP.trim() ? highlightedPolishedP : '&nbsp;'}</div>
</div>
</div>
`;
                    }

                    fullPolishedHtmlWithMarks = applyHighlights(escapeHtml(item.polishedText), item.changes, 'polished');
                }

                contentHTML = `
<h2 class="vocab-header">${escapeHtml(pageTitle)}</h2>
<div class="view-switcher">
<button class="view-btn active" data-view="full-text-${resultIndex}">閱覽全文</button>
<button class="view-btn" data-view="comparison-${resultIndex}">逐段比對</button>
</div>
<div id="full-text-${resultIndex}">
<div class="full-text-header">
<button class="icon-btn copy-full-text-btn" title="一鍵複製全文" data-text-to-copy="${encodedPolishedTextClean}">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
</button>
</div>
<div class="polished-text-content">${fullPolishedHtmlWithMarks.replace(/\n/g, '<br>')}</div>
</div>
<div id="comparison-${resultIndex}" class="hidden">
<div class="comparison-container">${comparisonHTML}</div>
</div>
`;

          } else { // Vocab type
                const examplesHTML = item.examples.map(ex => `<li>${escapeHtml(ex)}</li>`).join('');
                const vocabItemJson = escapeHtml(JSON.stringify(item));
                
                // [修訂] 在標題區加入「筆順演練」按鈕 (Feather Icon)
                contentHTML = `
                <h2 class="vocab-header">
                    <span style="flex-grow: 1;">${escapeHtml(pageTitle)}</span>
                    <div style="display:flex; gap:0.5rem;">
                        <button class="icon-btn practice-stroke-btn" data-vocab="${escapeHtml(item.vocab)}" title="筆順演練">
                           <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line></svg>
                        </button>
                        <button class="icon-btn save-vocab-btn" data-vocab-item='${vocabItemJson}' title="納入紀錄">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>
                        </button>
                    </div>
                </h2>
                <div class="vocab-definition-container">
                <p class="vocab-definition">${escapeHtml(item.definition)}</p>
                </div>
                <ul class="vocab-examples">${examplesHTML}</ul>
                `;
            }

            pageElement.innerHTML = `<div class="page-content ${viewModeClass}">${contentHTML}</div>`;
            book.appendChild(pageElement);

            if (item.type === 'word-polish-result' || item.type === 'prose-polish-result') {
                const switcher = pageElement.querySelector('.view-switcher');
                switcher.addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON' && !e.target.classList.contains('active')) {
                        switcher.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        const viewToShow = e.target.dataset.view;
                        const pageContent = e.target.closest('.page-content');
                        const fullTextView = pageContent.querySelector(`[id^="full-text-"]`);
                        const comparisonView = pageContent.querySelector(`[id^="comparison-"]`);

                        fullTextView.classList.toggle('hidden', !viewToShow.startsWith('full-text'));
                        comparisonView.classList.toggle('hidden', !viewToShow.startsWith('comparison'));
                    }
                });
            }
        });

        const newPage = Math.min(currentPageBeforeRepagination, state.totalPages - 1);
        goToPage(newPage, true);

    }, 50);
}

function goToPage(pageNum, immediate = false) {
if (state.totalPages === 0) return;
const pageIndex = Math.max(0, Math.min(pageNum, state.totalPages - 1));
state.currentPageNum = pageIndex;
currentTranslate = -pageIndex * bookContainer.clientWidth;
book.style.transition = immediate ? 'none' : 'transform 0.4s ease-out';
book.style.transform = `translateX(${currentTranslate}px)`;
updatePaginationDisplay();
}

function updatePaginationDisplay() {
if (readerPagination) {
if (state.totalPages > 1) {
readerPagination.textContent = `${state.currentPageNum + 1} / ${state.totalPages}`;
} else {
readerPagination.textContent = '';
}
}
}

// --- 7. 翻頁與互動處理 ---
function dragStart(e) { if(state.totalPages <= 1) return; isDragging = true; dragStartX = e.touches ? e.touches[0].clientX : e.clientX; startTranslate = currentTranslate; book.style.transition = 'none'; }
function dragMove(e) { if (!isDragging) return; const currentX = e.touches ? e.touches[0].clientX : e.clientX; const diff = currentX - dragStartX; currentTranslate = startTranslate + diff; book.style.transform = `translateX(${currentTranslate}px)`; }
function dragEnd() { if (!isDragging) return; isDragging = false; const threshold = bookContainer.clientWidth / 5; const endTranslate = -state.currentPageNum * bookContainer.clientWidth; const movedBy = currentTranslate - endTranslate; if (movedBy < -threshold && state.currentPageNum < state.totalPages - 1) { goToPage(state.currentPageNum + 1); } else if (movedBy > threshold && state.currentPageNum > 0) { goToPage(state.currentPageNum - 1); } else { goToPage(state.currentPageNum); } }








	
async function handleReaderClick(e) {
    const target = e.target;


// [新增] 處理「筆順演練」按鈕點擊
    const strokeBtn = target.closest('.practice-stroke-btn');
    if (strokeBtn) {
        e.preventDefault();
        const vocab = strokeBtn.dataset.vocab;
        if (vocab) {
            openStrokeModal(vocab);
        }
        return;
    }
	
    // [修訂] 新增儲存詞彙按鈕的處理邏輯
    const saveBtn = target.closest('.save-vocab-btn');
    if (saveBtn) {
        e.preventDefault();
        const vocabItemData = saveBtn.dataset.vocabItem;
        if (vocabItemData) {
            try {
                const vocabItem = JSON.parse(vocabItemData);
                if (confirm(`您確定要將「${vocabItem.vocab}」納入紀錄嗎？`)) {
                    addToLookupHistory([vocabItem]); // 以陣列形式傳遞單個詞彙
                    showToast(`「${vocabItem.vocab}」已納入紀錄`, 'success');
                    // 讓按鈕失效，避免重複儲存
                    saveBtn.disabled = true;
                    saveBtn.style.opacity = '0.5';
                    saveBtn.style.cursor = 'default';
                }
            } catch (error) {
                console.error("Failed to parse vocab item data:", error);
                showToast('儲存失敗，資料格式錯誤', 'error');
            }
        }
        return; // 結束函數
    }

    // 處理「複製全文」按鈕的邏輯 (保留不變)
    const copyBtn = target.closest('.copy-full-text-btn');
    if (copyBtn) {
        e.preventDefault();
        const textToCopy = copyBtn.dataset.textToCopy;
        if (textToCopy) {
            navigator.clipboard.writeText(textToCopy.replace(/&quot;/g, '"').replace(/&amp;/g, '&')).then(() => {
                showToast('已複製到剪貼簿', 'success');
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                showToast('複製失敗，瀏覽器不支援或未授權', 'error');
            });
        }
        return; // 結束函式
    }

    // --- [修訂] 新增點擊潤色詞彙以儲存的邏輯 ---
    const markElement = target.closest('mark.mark-polished');
    const pageContent = target.closest('.page-content');

    // 條件：必須點在 polished mark 上，且必須是在 word-polish-view 模式下
    if (markElement && pageContent && pageContent.classList.contains('word-polish-view')) {
        // 如果該詞彙正在讀取中，則不執行任何操作
        if (markElement.classList.contains('is-loading')) return;

        const wordToSave = markElement.textContent.trim();

        if (!wordToSave) return; // 如果點到空的標籤，不執行

        // 跳出確認視窗，讓使用者確認
        if (confirm(`您確定要將「${wordToSave}」加入詞彙表嗎？`)) {
            // 如果使用者點擊「確定」，則呼叫我們剛剛建立的輔助函式
            savePolishedWordToHistory(wordToSave, markElement);
        }
    }
}



// ==========================================
// === [終極修復版] 筆順演練模組 (延遲綁定) ===
// ==========================================

// 狀態變數
let hanziWriterInstance = null;
let currentStrokeVocab = '';
let currentStrokeCharIndex = 0;
let isStrokeEventsBound = false;
// [新增] 標記整組詞彙是否已完成測驗
let isStrokeWordComplete = false;

// DOM 元素獲取 helper
function getStrokeElements() {
    return {
        modal: document.getElementById('stroke-modal'),
        closeBtn: document.getElementById('stroke-close-btn'),
        charSwitcher: document.getElementById('stroke-char-switcher'),
        statusText: document.getElementById('stroke-status-text'),
        animateBtn: document.getElementById('stroke-animate-btn'),
        quizBtn: document.getElementById('stroke-quiz-btn'),
        targetDiv: document.getElementById('hanzi-target')
    };
}

// 核心修復：綁定按鈕功能的函式 (只執行一次)
// 核心修復：綁定按鈕功能的函式
function bindStrokeModalEvents() {
    if (isStrokeEventsBound) return;
 
    const els = getStrokeElements();
    
    if (!els.modal || !els.closeBtn || !els.animateBtn || !els.quizBtn) {
        console.error("找不到筆順視窗的按鈕元素，無法綁定事件！");
        return;
    }
 
    console.log("正在綁定筆順視窗按鈕事件...");
 
    // 1. 關閉按鈕
    els.closeBtn.onclick = function() {
        closeStrokeModal();
    };
 
    // 2. 點擊遮罩關閉
    els.modal.onclick = function(e) {
        if (e.target === els.modal) {
            closeStrokeModal();
        }
    };
 
    // 3. 播放動畫按鈕
    els.animateBtn.onclick = function() {
        animateStrokeChar();
    };
 
    // 4. [修訂] 開始測驗按鈕 (加入重置邏輯)
    els.quizBtn.onclick = function() {
        console.log("點擊開始測驗");
        
        // 如果整組詞彙都寫完了，點擊此按鈕應該要「從頭開始」
        if (isStrokeWordComplete) {
            // 1. 重置索引為 0
            currentStrokeCharIndex = 0;
            // 2. 重置完成狀態
            isStrokeWordComplete = false;
            
            // 3. 更新上方字元按鈕的 UI (第一個變 active)
            const btns = document.querySelectorAll('.char-btn');
            btns.forEach((btn, index) => {
                btn.classList.toggle('active', index === 0);
            });
 
            // 4. 載入第一個字，並自動開始測驗
            initHanziWriter(currentStrokeVocab[0], true);
        } else {
            // 否則，只是重測當前這一個字
            startStrokeQuiz();
        }
    };
 
    isStrokeEventsBound = true;
    console.log("按鈕事件綁定成功！");
}
// 動態載入函式庫
function loadHanziWriterLib() {
    return new Promise((resolve, reject) => {
        if (typeof HanziWriter !== 'undefined') {
            resolve();
            return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/hanzi-writer@3.5/dist/hanzi-writer.min.js';
        script.onload = () => { console.log("Hanzi Writer 載入成功"); resolve(); };
        script.onerror = () => reject(new Error("無法載入筆順函式庫，請檢查網路。"));
        document.head.appendChild(script);
    });
}

// 1. 開啟彈窗 (進入點)
async function openStrokeModal(vocab) {
    console.log("嘗試開啟筆順視窗:", vocab);
    
    const els = getStrokeElements();
    
    // [關鍵修復] 在開啟視窗時，才嘗試綁定按鈕
    // 這樣能確保 HTML 元素一定存在
    bindStrokeModalEvents(); 

    if (!els.modal) {
        alert("錯誤：找不到筆順視窗 HTML，請檢查代碼是否完整。");
        return;
    }

    els.statusText.textContent = "載入中...";
    els.modal.classList.add('is-visible');

    try {
        await loadHanziWriterLib(); 
        currentStrokeVocab = vocab;
        currentStrokeCharIndex = 0;
        renderCharSwitcher();
        initHanziWriter(currentStrokeVocab[0]);
    } catch (error) {
        alert(error.message);
        closeStrokeModal();
    }
}

// 2. 關閉彈窗
function closeStrokeModal() {
    const els = getStrokeElements();
    if (els.modal) els.modal.classList.remove('is-visible');
    
    if (hanziWriterInstance) {
        // 清除實例
        hanziWriterInstance = null;
    }
    if (els.targetDiv) els.targetDiv.innerHTML = '';
}

// 3. 生成字元切換器
function renderCharSwitcher() {
    const els = getStrokeElements();
    if (!els.charSwitcher) return;
    els.charSwitcher.innerHTML = '';
    
    if (currentStrokeVocab.length <= 1) {
        els.charSwitcher.style.display = 'none';
        return;
    }
    
    els.charSwitcher.style.display = 'flex';
    for (let i = 0; i < currentStrokeVocab.length; i++) {
        const btn = document.createElement('button');
        btn.className = `char-btn ${i === 0 ? 'active' : ''}`;
        btn.textContent = currentStrokeVocab[i];
        
        // 這裡直接使用 onclick 屬性，最穩當
        btn.onclick = function() {
            document.querySelectorAll('.char-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentStrokeCharIndex = i;
            initHanziWriter(currentStrokeVocab[i]);
        };
        
        els.charSwitcher.appendChild(btn);
    }
}

// 4. 初始化 Hanzi Writer
// 4. 初始化 Hanzi Writer (修訂版：加入重置完成標記)
function initHanziWriter(char, autoStartQuiz = false) {
    // [新增] 只要載入新字，就代表當前狀態未完成 (或者正在進行中)
    isStrokeWordComplete = false;
 
    const els = getStrokeElements();
    if (!els.targetDiv) return;
 
    // 字形/異體字手動校正表
    const charCorrectionMap = {
        // '顚': '顛' 
    };
    
    const targetChar = charCorrectionMap[char] || char;
 
    els.targetDiv.innerHTML = ''; 
    els.statusText.textContent = "載入字型數據中...";
    els.statusText.style.color = 'var(--text-secondary-light)';
 
    const isDark = document.body.classList.contains('dark-mode');
    
    try {
        hanziWriterInstance = HanziWriter.create('hanzi-target', targetChar, {
            width: 300,
            height: 300,
            padding: 20,
            showOutline: true,
            strokeAnimationSpeed: 1,
            delayBetweenStrokes: 200,
            strokeColor: isDark ? '#7A9E9F' : '#5e7067',
            radicalColor: '#d69a92',
            outlineColor: isDark ? '#5C554E' : '#e0ddd7',
            drawingColor: isDark ? '#7A9E9F' : '#5e7067',
            drawingWidth: 25,
            showHintAfterMisses: 1,
            highlightOnComplete: true,
            // 強制使用繁體中文資料庫
            charDataLoader: function(char, onComplete) {
                fetch('https://cdn.jsdelivr.net/npm/hanzi-writer-data-traditional@2.0/' + char + '.json')
                .then(res => {
                    if (!res.ok) throw new Error('Network response was not ok');
                    return res.json();
                })
                .then(charData => onComplete(charData))
                .catch(err => {
                    console.warn("繁體字庫載入失敗，嘗試載入預設字庫:", err);
                    fetch('https://cdn.jsdelivr.net/npm/hanzi-writer-data@2.0/' + char + '.json')
                        .then(res => res.json())
                        .then(charData => onComplete(charData));
                });
            }
        });
 
        setTimeout(() => {
             if (autoStartQuiz) {
                 els.statusText.textContent = `載入完成，請書寫「${targetChar}」...`;
                 startStrokeQuiz();
             } else {
                 els.statusText.textContent = `當前字元：${targetChar}。請選擇「播放」或「測驗」。`;
                 hanziWriterInstance.animateCharacter();
             }
        }, 600);
 
    } catch (e) {
        console.error("Init Error:", e);
        els.statusText.textContent = "字型載入失敗，請重試。";
    }
}
 

// 5. 播放動畫
function animateStrokeChar() {
    const els = getStrokeElements();
    if (!hanziWriterInstance) {
        alert("請等待字型載入完成");
        return;
    }
    
    hanziWriterInstance.cancelQuiz();
    
    els.statusText.textContent = "演示筆順中...";
    els.statusText.style.color = 'var(--accent-color)';
    
    hanziWriterInstance.animateCharacter({
        onComplete: function() {
            els.statusText.textContent = "演示完畢";
        }
    });
}

// 6. 開始測驗 (修訂版：加入自動跳轉下一字邏輯)
function startStrokeQuiz() {
    const els = getStrokeElements();
    
    if (!hanziWriterInstance) {
        alert("資料尚未載入完成");
        return;
    }
    
    try {
        hanziWriterInstance.cancelQuiz();
        hanziWriterInstance.hideCharacter();
    } catch(e) { console.warn(e); }
    
    els.statusText.textContent = "測驗開始！請用滑鼠或手指書寫...";
    els.statusText.style.color = '#E65100';
    
    hanziWriterInstance.quiz({
        onMistake: function(strokeData) {
            els.statusText.textContent = "筆順錯誤，請看提示。";
            els.statusText.style.color = '#e74c3c';
            if (navigator.vibrate) navigator.vibrate(100);
        },
        onCorrectStroke: function(strokeData) {
            els.statusText.textContent = "正確！繼續下一筆。";
            els.statusText.style.color = 'var(--accent-color)';
        },
        onComplete: function(summaryData) {
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
 
            // 判斷是否還有下一個字
            if (currentStrokeVocab.length > 1 && currentStrokeCharIndex < currentStrokeVocab.length - 1) {
                
                const nextChar = currentStrokeVocab[currentStrokeCharIndex + 1];
                els.statusText.textContent = `太棒了！1秒後自動切換至：「${nextChar}」`;
                els.statusText.style.color = '#4CAF50';
 
                setTimeout(() => {
                    currentStrokeCharIndex++;
                    
                    const btns = document.querySelectorAll('.char-btn');
                    btns.forEach((btn, index) => {
                        btn.classList.toggle('active', index === currentStrokeCharIndex);
                    });
 
                    initHanziWriter(currentStrokeVocab[currentStrokeCharIndex], true);
 
                }, 1200);
 
            } else {
                // [修訂] 如果是最後一個字，顯示完成訊息，並設定完成標記
                els.statusText.textContent = `恭喜完成！總錯誤次數: ${summaryData.totalMistakes}。點擊「開始測驗」可重新練習。`;
                els.statusText.style.color = '#4CAF50';
                
                // 標記整組詞彙已完成
                isStrokeWordComplete = true;
            }
        }
    });
}
  
function showToast(message, type = 'info') {
vocabToast.textContent = message;
vocabToast.className = 'vocab-toast'; // Reset classes
if (type === 'success') vocabToast.classList.add('success');
else if (type === 'error') vocabToast.classList.add('error');

vocabToast.classList.add('show');
setTimeout(() => {
vocabToast.classList.remove('show');
}, 3000);
}

// --- 8. 歷史紀錄相關函式 ---
function showHistory() {
updateHistoryModalUI();
renderHistory();
historyModal.classList.add('is-visible');
}

function hideHistory() {
historyModal.classList.remove('is-visible');
}

function switchHistoryTab(e) {
const newTab = e.target.dataset.historyType;
if (newTab === state.activeHistoryTab) return;

state.activeHistoryTab = newTab;
historyTabBtns.forEach(btn => {
btn.classList.toggle('active', btn.dataset.historyType === newTab);
});

historySearch.value = ''; 
updateHistoryModalUI();
renderHistory();
}

function updateHistoryModalUI() {
historySort.innerHTML = '';
if (state.activeHistoryTab === 'lookup') {
historyTitle.textContent = '詞彙表';
historySearch.placeholder = '按詞彙搜尋...';
historySearch.type = 'search';
[
{ value: 'date_desc', text: '按生成日期 (新到舊)' },
{ value: 'date_asc', text: '按生成日期 (舊到新)' },
].forEach(opt => historySort.add(new Option(opt.text, opt.value)));
} else { // polishing
historyTitle.textContent = '潤色紀錄';
historySearch.placeholder = '按篇名搜尋...';
historySearch.type = 'search';
[
{ value: 'date_desc', text: '按生成日期 (新到舊)' },
{ value: 'date_asc', text: '按生成日期 (舊到新)' },
].forEach(opt => historySort.add(new Option(opt.text, opt.value)));
}
}

function deleteAllHistoryForCurrentTab() {
const tab = state.activeHistoryTab;
const tabName = tab === 'lookup' ? '詞彙表' : '潤色紀錄';
const historyArray = tab === 'lookup' ? state.lookupHistory : state.polishingHistory;

if (historyArray.length === 0) return;
if (confirm(`您確定要刪除所有「${tabName}」嗎？此操作無法復原。`)) {
if (tab === 'lookup') {
state.lookupHistory = [];
localStorage.setItem('vocabHistory_v3', '[]');
} else {
state.polishingHistory = [];
localStorage.setItem('polishingHistory_v1', '[]');
}
renderHistory();
}
}


function renderHistory() {
    const tab = state.activeHistoryTab;
    let items = tab === 'lookup' ? [...state.lookupHistory] : [...state.polishingHistory];
    const term = historySearch.value.trim();

    if (term) {
        const lowerCaseTerm = term.toLowerCase();
        if (tab === 'lookup') {
            items = items.filter(i => i.vocab && i.vocab.toLowerCase().includes(lowerCaseTerm));
        } else { // polishing
            items = items.filter(i => i.title && i.title.toLowerCase().includes(lowerCaseTerm));
        }
    }

    items.sort((a, b) => {
        const sortOrder = historySort.value;
        if (sortOrder === 'date_asc') {
            return new Date(a.generatedDate) - new Date(b.generatedDate);
        }
        return new Date(b.generatedDate) - new Date(a.generatedDate);
    });

    if (items.length === 0) {
        const msg = term ? '找不到符合條件的紀錄。' :
            tab === 'lookup' ? '目前沒有詞彙表。' : '目前沒有潤色紀錄。';
        historyList.innerHTML = `<li class="no-history-msg">${msg}</li>`;
    } else {
        historyList.innerHTML = items.map((item, index) => {
            if (tab === 'lookup') {
                // [修訂] 在歷史紀錄中加入筆順演練按鈕
                return `
<li data-history-id="${item.id}" data-type="lookup">
<div class="history-item-content">
<div class="history-list-item-title">${index + 1}. ${item.vocab}</div>
<div class="history-list-item-meta">
${new Date(item.generatedDate).toLocaleDateString('zh-TW')}
</div>
</div>
<div class="history-item-actions">
<button class="icon-btn practice-stroke-history-btn" data-vocab="${item.vocab}" title="筆順演練">
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line></svg>
</button>
<button class="icon-btn regenerate-history-btn" title="重新生成此詞彙的解釋與例句">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8h-6V2l2.25 2.25A12.012 12.012 0 0 0 12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 9-4.25 9-4.25"/></svg>
</button>
<button class="icon-btn delete-history-btn" title="刪除此紀錄">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
</button>
</div>
</li>`;
            } else { // polishing
                const polishType = item.type === 'word-polish-result' ? '詞彙潤色' : '文句潤色';
                return `
<li data-history-id="${item.id}" data-type="polishing">
<div class="history-item-content">
<div class="history-list-item-title">${index + 1}. ${item.title}</div>
<div class="history-list-item-meta">
${polishType} - ${new Date(item.generatedDate).toLocaleDateString('zh-TW')}
</div>
</div>
<div class="history-item-actions">
<button class="icon-btn edit-history-title-btn" title="修訂篇名">
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
</button>
<button class="icon-btn delete-history-btn" title="刪除此紀錄">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
</button>
</div>
</li>`;
            }
        }).join('');
    }
}


	
async function regenerateLookupHistoryItem(id, element) {
const item = state.lookupHistory.find(i => i.id === id);
if (!item) return;

element.classList.add('is-loading');
try {
const results = await fetchVocabulary({ mode: 'lookup', query: item.vocab });
if (results && results.length > 0) {
const newItem = results[0];
const index = state.lookupHistory.findIndex(i => i.id === id);
if (index !== -1) {
state.lookupHistory[index] = newItem;
localStorage.setItem('vocabHistory_v3', JSON.stringify(state.lookupHistory));
renderHistory(); 
}
} else {
element.classList.remove('is-loading');
}
} catch(error) {
showError(`重新生成失敗: ${error.message}`);
element.classList.remove('is-loading');
}
}

function handleHistoryListClick(e) {
    const li = e.target.closest('li[data-history-id]');
    if (!li) return;

    const id = li.dataset.historyId;
    const type = li.dataset.type;
    const sourceArray = type === 'lookup' ? state.lookupHistory : state.polishingHistory;
    const item = sourceArray.find(i => i.id === id);
    if (!item) return;

    const title = item.vocab || item.title;

    // [新增] 歷史紀錄中的筆順演練按鈕
    if (e.target.closest('.practice-stroke-history-btn')) {
        // 直接開啟筆順彈窗，不進入閱讀模式
        if (item.vocab) {
            openStrokeModal(item.vocab);
        }
        return;
    }

    if (e.target.closest('.edit-history-title-btn')) {
        const newTitle = prompt('請修訂此紀錄的篇名：', item.title);
        if (newTitle && newTitle.trim() !== '' && newTitle.trim() !== item.title) {
            item.title = newTitle.trim();
            localStorage.setItem('polishingHistory_v1', JSON.stringify(state.polishingHistory));
            renderHistory();
            showToast('篇名已修訂', 'success');
        }
        return;
    }

    if (e.target.closest('.regenerate-history-btn')) {
        if (confirm(`您確定要重新生成「${title}」的解釋與例句嗎？這將會覆蓋現有紀錄。`)) {
            regenerateLookupHistoryItem(id, li);
        }
        return;
    }

    if (e.target.closest('.delete-history-btn')) {
        if (confirm(`您確定要刪除「${title}」這筆紀錄嗎？`)) {
            if (type === 'lookup') {
                state.lookupHistory = state.lookupHistory.filter(i => i.id !== id);
                localStorage.setItem('vocabHistory_v3', JSON.stringify(state.lookupHistory));
            } else {
                state.polishingHistory = state.polishingHistory.filter(i => i.id !== id);
                localStorage.setItem('polishingHistory_v1', JSON.stringify(state.polishingHistory));
            }
            renderHistory();
        }
        return;
    }

    // 點擊項目本身進入閱讀模式 (如果沒有點到上面的按鈕)
    if (e.target.closest('.history-item-content')) {
        state.currentResults = [item];
        state.currentPageNum = 0;
        displayResultsAsBook(state.currentResults);
        switchToReaderView();
        hideHistory();
    }
}

async function savePolishedWordToHistory(word, element) {
    if (!word || !element) return;

    // 1. 顯示讀取狀態
    element.classList.add('is-loading');

    try {
        // 2. 使用現有的 API 函式來查詢詞彙的詳細資料
        const results = await fetchVocabulary({ mode: 'lookup', query: word });

        if (results && results.length > 0) {
            // 3. 成功獲取資料後，存入詞彙表
            addToLookupHistory(results);
            showToast(`「${word}」已成功加入詞彙表！`, 'success');
        } else {
            // 如果 API 沒能返回有效結果
            throw new Error("找不到該詞彙的詳細解釋。");
        }
    } catch (error) {
        console.error('儲存潤色詞彙時出錯:', error);
        showToast(`儲存「${word}」失敗: ${error.message}`, 'error');
    } finally {
        // 4. 無論成功或失敗，都移除讀取狀態
        element.classList.remove('is-loading');
    }
}

// --- 9. 測驗功能函式 ---

// [REVISION START] New functions and modifications for mixable quiz types
function updateDynamicQuizSections() {
    const type = state.quizSettings.type;
    const isMixMode = (type === 4);

    // Show/hide the container for selecting which types to mix
    quizMixOptionsContainer.classList.toggle('hidden', !isMixMode);
    
    // Show/hide the sentence source option (AI vs Record) based on current selections
    const involvesSentenceFill = (type === 3) || (isMixMode && state.quizSettings.mixedTypes.includes(3));
    quizSentenceSourceContainer.classList.toggle('hidden', !involvesSentenceFill);
    
    // Adjust the numbering of the subsequent section labels.
    // This keeps the logic simple and localized to avoid breaking other parts.
    let sectionNumber = 2;
    if (!quizMixOptionsContainer.classList.contains('hidden')) {
        quizMixOptionsContainer.querySelector('.quiz-setup-label').textContent = '二、選擇混合題型';
        sectionNumber++;
    }
    if (!quizSentenceSourceContainer.classList.contains('hidden')) {
        quizSentenceSourceContainer.querySelector('.quiz-setup-label').textContent = '三、選擇「句子填空」來源';
        sectionNumber++;
    }
    quizScopeLabel.textContent = `四、選擇出題範圍`;
    if (sectionNumber === 2) quizScopeLabel.textContent = `二、選擇出題範圍`;
    if (sectionNumber === 3) quizScopeLabel.textContent = `三、選擇出題範圍`;
}

function handleQuizMixSelect(e) {
    const btn = e.target.closest('.quiz-setting-btn[data-mix-type]');
    if (!btn) return;

    btn.classList.toggle('active');
    const mixType = parseInt(btn.dataset.mixType);

    if (btn.classList.contains('active')) {
        if (!state.quizSettings.mixedTypes.includes(mixType)) {
            state.quizSettings.mixedTypes.push(mixType);
        }
    } else {
        state.quizSettings.mixedTypes = state.quizSettings.mixedTypes.filter(t => t !== mixType);
    }
    updateDynamicQuizSections();
}
// [REVISION END]


async function fetchAIBatchSentences(vocabArray) {
    if (!vocabArray || vocabArray.length === 0) return {};
    const systemPrompt = `針對以下 JSON 陣列中的每一個詞彙，請創造一個使用該詞彙的繁體中文句子，並將句子中的該詞彙替換為_______。
    
    你的回傳內容【必須】是單一的 JSON 物件，物件的 key 是原始詞彙，value 是生成的填空句子，句子必須具文學性。不要包含任何 markdown 語法或額外說明。

    詞彙列表:
    ${JSON.stringify(vocabArray)}

    JSON 格式範例:
    {
        "詞彙一": "這是包含_______的第一個句子。",
        "詞彙二": "這是包含_______的第二個句子。"
    }`;
    
    try {
        const response = await fetch(CLOUDFLARE_WORKER_URL, {
            method: 'POST',
            // GAS Web App 不需要 Authorization Header
            body: JSON.stringify({
                model: "gemini",
                messages: [{ role: "user", content: systemPrompt }],
                response_format: { type: "json_object" },
                max_tokens: 2048,
                temperature: 0.8
            })
        });
        if (!response.ok) throw new Error(`API 請求失敗，狀態碼：${response.status}`);
        const data = await response.json();

        // ★★★ 調用美化 Log 函數 ★★★
        logProviderInfo(data, "AISentenceBatch");

        if (data.error) throw new Error(`生成失敗: ${data.error}`);

        return parseJsonFromResponse(data.choices?.[0]?.message?.content);
    } catch (error) {
        console.error("AI Sentence Batch Fetch Error:", error);
        showQuizError("AI 出題時發生錯誤，請稍後重試。");
        return null;
    }
}

async function evaluateSentence(vocab, userSentence) {
    // 使用傳統字串拼接，以避免多行模板字串可能引發的解析錯誤
    const systemPrompt = '你是一位精準、嚴謹的中文文學編輯與詞彙學家。你的任務是深入分析學生使用「' + vocab + '」一詞所造的句子，並提供專業的批改建議。\n\n' +
        '你的分析必須遵循以下【三步分析法】，並依此順序判斷句子的核心問題：\n\n' +
        '1.  **第一步：分析「詞彙配搭」(Collocation)**\n' +
        '    *   檢查「' + vocab + '」與句子中其他詞語的搭配是否自然、合乎習慣用法。\n' +
        '    *   例如，該形容詞是否能修飾這個名詞？該動詞的施動者或受動者是否恰當？\n\n' +
        '2.  **第二步：分析「語意邏輯」(Semantics)**\n' +
        '    *   如果詞彙配搭沒問題，接著檢查整個句子的意思是否合乎邏輯、清晰且完整。\n' +
        '    *   例如，「自由」是否可以用「玩」這個動詞來描述？句子的比喻或陳述是否成立？\n\n' +
        '3.  **第三步：分析「語法結構」(Grammar)**\n' +
        '    *   最後，檢查是否有語法、錯別字或標點符號的錯誤。\n\n' +
        '你的回傳內容【必須】是單一的 JSON 物件，不含任何其他文字或 markdown 語法，此物件須包含以下 key：\n\n' +
        '*   `"is_correct"`: (boolean) 僅在上述三步分析**完全**通過時，才為 `true`。\n' +
        '*   `"comment"`: (string) 你的評語【必須】一針見血地指出最根本的錯誤。例如，如果第一步「詞彙配搭」就錯了，就必須明確指出是哪個詞跟哪個詞搭配錯誤，而不是給出「語意不清」這種模糊的評語。\n' +
        '*   `"visual"`: (string) 根據恰當程度，給予以下三者之一的標籤： "appropriate"（完全正確）、"needs_improvement"（有小瑕疵）、"incorrect"（有根本性錯誤）。\n' +
        '*   `"corrected_sentence"`: (string) 【重要】你的訂正建議**必須**修正句子的**根本問題**。如果詞彙配搭或語意錯誤，你應該**重寫一個能正確使用「' + vocab + '」的句子**，而不是在錯誤的句子結構上小修小補。\n\n' +
        '---\n' +
        '**批改範例與要求：**\n\n' +
        '**情境：** 詞彙為「寂寥」，學生造句為「寂寥的自由沒人玩了」。\n\n' +
        '*   **【錯誤的批改方式】(你不可以這樣做):**\n' +
        '    *   `"comment": "句子語意表達不夠清楚。"` (評語太模糊)\n' +
        '    *   `"corrected_sentence": "寂寥的自由讓人再也不想玩了。"` (修正無效，因為沒有解決根本的詞彙配搭錯誤)\n\n' +
        '*   **【正確的批改方式】(你必須這樣做):**\n' +
        '    *   `"comment": "詞彙配搭錯誤。「寂寥」通常形容心境或環境，無法用來修飾「自由」；同時，動詞「玩」也與「自由」無法搭配。"` (評語精準，點出兩個核心問題)\n' +
        '    *   `"corrected_sentence": "在這座空無一人的城市裡，他感到一種深刻的寂寥。"` (完全重寫了一個正確使用「寂寥」的句子)\n' +
        '---\n\n' +
        '現在，請根據以上規則，批改以下句子：\n' +
        '*   **待批改詞彙:** 「' + vocab + '」\n' +
        '*   **學生造句:** 「' + userSentence + '」';

    try {
        const response = await fetch(CLOUDFLARE_WORKER_URL, {
            method: 'POST',
            // GAS Web App 不需要 Authorization Header
            body: JSON.stringify({
                model: "gemini",
                messages: [{ role: "user", content: systemPrompt }],
                response_format: { type: "json_object" },
                max_tokens: 512,
                temperature: 0.5
            })
        });
        if (!response.ok) throw new Error(`API 請求失敗，狀態碼：${response.status}`);
        const data = await response.json();

        // ★★★ 調用美化 Log 函數 ★★★
        logProviderInfo(data, "SentenceEval");

        if (data.error) throw new Error(`生成失敗: ${data.error}`);

        return parseJsonFromResponse(data.choices?.[0]?.message?.content);
    } catch (error) {
        console.error("AI Sentence Evaluation Error:", error);
        return {
            is_correct: false,
            comment: '批改時發生網路錯誤，請稍後再試。',
            visual: 'incorrect',
            corrected_sentence: '無法提供訂正建議。'
        };
    }
}


function showQuiz() {
    quizErrorMessage.classList.add('hidden');
    quizGameScreen.classList.add('hidden');
    quizSetupScreen.classList.remove('hidden');
    quizTitle.classList.remove('hidden');
    quizScore.classList.add('hidden');
    quizProgressCounter.classList.add('hidden');
    quizTitle.textContent = '測驗設定';

    // Ensure the default active button reflects the state
    quizTypeSelection.querySelectorAll('.quiz-setting-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.quizType) === state.quizSettings.type);
    });
    
    populateQuizVocabSelectionList();
    updateQuizVocabSelectionCount();
    
    updateDynamicQuizSections(); // [REVISION] Call to set initial visibility

    quizContainer.classList.remove('hidden');
}

function hideQuiz() {
quizContainer.classList.add('hidden');
state.quizGame = {
isActive: false, score: 0, questions: [], currentQuestionIndex: -1, currentQuestion: null
};
state.quizSettings.aiGeneratedSentences = null;
}

function handleQuizTypeSelect(e) {
    const btn = e.target.closest('.quiz-setting-btn');
    if (!btn) return;
    
    quizTypeSelection.querySelectorAll('.quiz-setting-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const type = parseInt(btn.dataset.quizType);
    state.quizSettings.type = type;

    updateDynamicQuizSections(); // [REVISION]
}

function handleSentenceSourceSelect(e) {
    const btn = e.target.closest('.quiz-scope-btn');
    if (!btn) return;
    quizSentenceSourceSelection.querySelectorAll('.quiz-scope-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.quizSettings.sentenceSource = btn.dataset.source;
}

function handleQuizScopeSelect(e) {
const btn = e.target.closest('.quiz-scope-btn');
if (!btn) return;
quizScopeSelection.querySelectorAll('.quiz-scope-btn').forEach(b => b.classList.remove('active'));
btn.classList.add('active');
state.quizSettings.scope = btn.dataset.scope;

quizVocabSelectionContainer.classList.toggle('hidden', state.quizSettings.scope !== 'select');
}

function populateQuizVocabSelectionList() {
quizVocabSelectionList.innerHTML = '';
if (state.lookupHistory.length === 0) {
quizVocabSelectionList.innerHTML = '<li class="no-history-msg">詞彙表無內容，請先查找或生成詞彙。</li>';
return;
}
state.lookupHistory.forEach(item => {
const li = document.createElement('li');
li.dataset.vocabId = item.id;
li.textContent = item.vocab;
if (state.quizSettings.selectedVocabIds.includes(item.id)) {
li.classList.add('selected');
}
quizVocabSelectionList.appendChild(li);
});
}

function handleQuizVocabItemSelect(e) {
const li = e.target.closest('li[data-vocab-id]');
if (!li) return;
const id = li.dataset.vocabId;
li.classList.toggle('selected');
if (li.classList.contains('selected')) {
if (!state.quizSettings.selectedVocabIds.includes(id)) {
state.quizSettings.selectedVocabIds.push(id);
}
} else {
state.quizSettings.selectedVocabIds = state.quizSettings.selectedVocabIds.filter(vid => vid !== id);
}
updateQuizVocabSelectionCount();
}

function selectAllQuizVocab(shouldSelectAll) {
const items = quizVocabSelectionList.querySelectorAll('li[data-vocab-id]');
const allIds = Array.from(items).map(li => li.dataset.vocabId);

state.quizSettings.selectedVocabIds = shouldSelectAll ? allIds : [];

items.forEach(li => {
li.classList.toggle('selected', shouldSelectAll);
});
updateQuizVocabSelectionCount();
}

function updateQuizVocabSelectionCount() {
quizSelectedCount.textContent = state.quizSettings.selectedVocabIds.length;
}

function showQuizError(message) {
quizErrorMessage.textContent = message;
quizErrorMessage.classList.remove('hidden');
}

async function startQuiz() {
    quizErrorMessage.classList.add('hidden');
    let sourceVocab = [];

    // [REVISION] Add validation for mix mode
    if (state.quizSettings.type === 4 && state.quizSettings.mixedTypes.length === 0) {
        showQuizError('請至少選擇一種題型進行混合。');
        return;
    }

    if (state.quizSettings.scope === 'all') {
        sourceVocab = state.lookupHistory;
    } else {
        sourceVocab = state.lookupHistory.filter(item => state.quizSettings.selectedVocabIds.includes(item.id));
    }

    const minVocabCount = state.quizSettings.type === 5 ? 1 : 4;
    if (sourceVocab.length < minVocabCount) {
        showQuizError(`出題範圍的詞彙量不足 ${minVocabCount} 個，無法開始測驗。請擴充詞彙表或更改出題範圍。`);
        return;
    }

    setLoading(true, quizStartBtn, '準備題目中...');

    const type = state.quizSettings.type;
    const involvesAIGeneration = (type === 3 || (type === 4 && state.quizSettings.mixedTypes.includes(3))) && state.quizSettings.sentenceSource === 'ai';

    if (involvesAIGeneration) {
        const vocabForAISentences = sourceVocab.map(v => v.vocab);
        const aiSentences = await fetchAIBatchSentences(vocabForAISentences);
        if (!aiSentences) {
            setLoading(false, quizStartBtn);
            return; 
        }
        state.quizSettings.aiGeneratedSentences = aiSentences;
    }

    state.quizGame.questions = generateQuizQuestions(sourceVocab);

    // [修訂] 將隨機排序後的題目數量限制為最多 10 題
    state.quizGame.questions = state.quizGame.questions.slice(0, 10);

    if(state.quizGame.questions.length === 0){
        showQuizError('無法生成任何問題，可能的原因是詞彙資料不完整，或 AI 出題失敗。');
        setLoading(false, quizStartBtn);
        return;
    }

    state.quizGame.isActive = true;
    state.quizGame.score = 0;
    state.quizGame.currentQuestionIndex = -1;
    quizScoreValue.textContent = 0;

    quizSetupScreen.classList.add('hidden');
    quizGameScreen.classList.remove('hidden');
    quizTitle.classList.add('hidden');
    quizScore.classList.remove('hidden');
    quizProgressCounter.classList.remove('hidden');

    setLoading(false, quizStartBtn);
    displayNextQuizQuestion();
}


function generateQuizQuestions(sourceVocab) {
let potentialQuestions = [];
const desiredType = state.quizSettings.type;

const typeFunctions = {
1: generateVocabToDefQuestion,
2: generateDefToVocabQuestion,
3: generateSentenceFillQuestion,
5: generateSentenceMakingQuestion,
};

function generateVocabToDefQuestion(item, allVocab) {
const incorrectOptions = getIncorrectOptions(item, allVocab, 3, 'definition');
if (incorrectOptions.length < 3) return null;
return { questionText: item.vocab, correctAnswer: item.definition, options: shuffleArray([item.definition, ...incorrectOptions]), type: 1 };
}

function generateDefToVocabQuestion(item, allVocab) {
const incorrectOptions = getIncorrectOptions(item, allVocab, 3, 'vocab');
if (incorrectOptions.length < 3) return null;
return { questionText: item.definition, correctAnswer: item.vocab, options: shuffleArray([item.vocab, ...incorrectOptions]), type: 2 };
}

function generateSentenceFillQuestion(item, allVocab) {
    let sentences = [];
    if (state.quizSettings.sentenceSource === 'ai') {
        const aiSentence = state.quizSettings.aiGeneratedSentences?.[item.vocab];
        if (aiSentence) sentences.push(aiSentence);
    } else {
        sentences = item.examples.filter(sentence => sentence && sentence.includes(item.vocab));
    }

    return sentences.map(sentence => {
        const incorrectOptions = getIncorrectOptions(item, allVocab, 3, 'vocab');
        if (incorrectOptions.length < 3) return null; 
        return {
            questionText: sentence.replace(new RegExp(item.vocab, 'g'), ' _______ '),
            correctAnswer: item.vocab,
            options: shuffleArray([item.vocab, ...incorrectOptions]),
            type: 3
        };
    }).filter(q => q !== null); 
}


function generateSentenceMakingQuestion(item) {
    return { questionText: item.vocab, type: 5 };
}

sourceVocab.forEach(item => {
    if (!item || !item.vocab || !item.definition) return;

    if (desiredType === 4) { // 隨機混合
        // [REVISION] Use selected mix types instead of hardcoded array
        const availableTypes = state.quizSettings.mixedTypes;
        if (availableTypes.length === 0) return; // Should not happen due to validation
        
        const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        
        if (randomType === 3) {
            potentialQuestions.push(...typeFunctions[randomType](item, sourceVocab));
        } else if (typeFunctions[randomType]) {
            const q = typeFunctions[randomType](item, sourceVocab);
            if (q) potentialQuestions.push(q);
        }
    } else {
        if (desiredType === 3) {
            potentialQuestions.push(...typeFunctions[desiredType](item, sourceVocab));
        } else if (typeFunctions[desiredType]) {
            const q = typeFunctions[desiredType](item, sourceVocab);
            if (q) potentialQuestions.push(q);
        }
    }
});

return shuffleArray(potentialQuestions);
}

function getIncorrectOptions(correctItem, sourceVocab, count, field) {
return sourceVocab
.filter(item => item && item.id !== correctItem.id && item[field])
.sort(() => 0.5 - Math.random())
.slice(0, count)
.map(item => item[field]);
}

function shuffleArray(array) {
for (let i = array.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[array[i], array[j]] = [array[j], array[i]];
}
return array;
}

function displayNextQuizQuestion() {
    quizFeedbackText.textContent = '';
    quizOptionsArea.innerHTML = '';
    quizOptionsArea.classList.remove('hidden');
    quizSentenceArea.classList.add('hidden');
    quizAiFeedbackArea.classList.add('hidden');
    quizNextQuestionBtn.classList.add('hidden'); 
    quizSentenceInput.disabled = false;
    quizSentenceSubmitBtn.disabled = false;

    state.quizGame.currentQuestionIndex++;

    quizProgressCounter.textContent = `第 ${state.quizGame.currentQuestionIndex + 1} / ${state.quizGame.questions.length} 題`;

    if (state.quizGame.currentQuestionIndex >= state.quizGame.questions.length) {
        endQuiz();
        return;
    }

    const question = state.quizGame.questions[state.quizGame.currentQuestionIndex];
    state.quizGame.currentQuestion = question;

    const questionContainer = quizQuestionText.parentElement;
    
    // [新] 先清除舊的題型 class，再添加新的
    questionContainer.className = 'quiz-question-container'; // 重設為基礎 class
    questionContainer.classList.add(`quiz-type-${question.type}`); // 動態添加當前題型 class

    questionContainer.style.textAlign = (question.type === 2 || question.type === 3) ? 'left' : 'center';
    quizQuestionText.textContent = question.questionText;

    if(question.type === 5) {
        quizOptionsArea.classList.add('hidden');
        quizSentenceArea.classList.remove('hidden');
        quizSentenceInput.value = '';
        quizSentenceInput.focus();
    } else {
        question.options.forEach(option => {
            const button = document.createElement('button');
            button.className = 'quiz-option';
            button.textContent = option;
            quizOptionsArea.appendChild(button);
        });
    }
}


function handleQuizAnswer(e) {
const selectedButton = e.target.closest('.quiz-option');
if (!selectedButton || selectedButton.disabled) return;

const question = state.quizGame.currentQuestion;
const isCorrect = selectedButton.textContent === question.correctAnswer;

quizOptionsArea.querySelectorAll('.quiz-option').forEach(btn => btn.disabled = true);

if (isCorrect) {
state.quizGame.score++;
selectedButton.classList.add('correct');
} else {
state.quizGame.score--;
selectedButton.classList.add('incorrect');
quizOptionsArea.querySelectorAll('.quiz-option').forEach(btn => {
if (btn.textContent === question.correctAnswer) {
btn.classList.add('correct');
}
});
}

quizScoreValue.textContent = state.quizGame.score;

setTimeout(displayNextQuizQuestion, 2000);
}

async function handleSentenceSubmit(e){
    e.preventDefault();
    const userSentence = quizSentenceInput.value.trim();
    if (!userSentence) {
        alert("請輸入句子。");
        return;
    }
    
    setLoading(true, quizSentenceSubmitBtn, '批改中...');
    
    const question = state.quizGame.currentQuestion;
    const result = await evaluateSentence(question.questionText, userSentence);
    
    setLoading(false, quizSentenceSubmitBtn);
    quizSentenceSubmitBtn.dataset.originalText = "提交";
    
    if(result.is_correct) {
        state.quizGame.score++;
    } else {
        state.quizGame.score--;
    }
    quizScoreValue.textContent = state.quizGame.score;
    
    // [修訂] 組合評語和訂正建議
    let feedbackHTML = result.comment; // 顯示主要評語
    
    // 如果回答錯誤，且AI提供了訂正建議，則附加到回饋中
    if (!result.is_correct && result.corrected_sentence) {
        // 使用 <br> 換行，並用 <b> 強調標題
        feedbackHTML += `<br><br><b>訂正建議：</b> ${result.corrected_sentence}`;
    }
    
    // 使用 innerHTML 將包含HTML標籤的字串寫入
    quizAiComment.innerHTML = feedbackHTML;

    quizAiFeedbackArea.className = 'quiz-ai-feedback-area'; // Reset
    quizAiFeedbackArea.classList.add(result.visual);
    quizAiFeedbackArea.classList.remove('hidden');

    quizSentenceInput.disabled = true;
    quizSentenceSubmitBtn.disabled = true;
    quizNextQuestionBtn.classList.remove('hidden');
}

function endQuiz() {
quizGameScreen.classList.add('hidden');
quizSetupScreen.classList.remove('hidden');

quizTitle.classList.remove('hidden');
quizScore.classList.add('hidden');
quizProgressCounter.classList.add('hidden'); // [修訂四]
quizTitle.textContent = `測驗結束！您的最終得分是：${state.quizGame.score}`;

state.quizGame.isActive = false;
state.quizGame.questions = [];
state.quizSettings.aiGeneratedSentences = null;
}
}

document.addEventListener('DOMContentLoaded', initializeApp);



// =======================================================
// === 通用懸浮視窗與OCR整合邏輯 (從「神思」移植) ===
// =======================================================
document.addEventListener('DOMContentLoaded', function() {

    // --- 懸浮視窗核心邏輯 ---
    const modal = document.getElementById('outline-editor-modal');
    const modalTextarea = document.getElementById('modal-textarea');
    const modalTitle = document.getElementById('modal-title');
    const modalSaveBtn = document.getElementById('modal-save-btn');
    const modalCloseBtn = document.getElementById('modal-close-btn');

    if (!modal || !modalTextarea || !modalSaveBtn || !modalCloseBtn) {
        console.error("懸浮視窗的 HTML 結構不完整或未找到！");
        return;
    }

    let currentEditingElement = null;

    function openModalEditor(element) {
        currentEditingElement = element;
        modalTextarea.value = currentEditingElement.value;

        // 嘗試為視窗設定一個有意義的標題
        let titleText = '編輯內容'; // 預設標題
        let associatedLabel = null;
        if (element.id) {
            associatedLabel = document.querySelector(`label[for="${element.id}"]`);
        }
        if (associatedLabel) {
            titleText = `編輯「${associatedLabel.textContent.trim().replace(/[:：]/g, '')}」`;
        }
        modalTitle.textContent = titleText;

        modal.style.display = 'flex';
        modalTextarea.focus();
    }

    function closeModalEditor() {
        modal.style.display = 'none';
        currentEditingElement = null;
    }

    function saveAndCloseEditor() {
        if (currentEditingElement) {
            currentEditingElement.value = modalTextarea.value;
            // 如果您的工具有字數統計等功能，可以在這裡觸發更新事件
            // currentEditingElement.dispatchEvent(new Event('input'));
        }
        closeModalEditor();
    }

    // 主事件監聽器：監聽頁面上對輸入框的點擊
    document.body.addEventListener('click', function(event) {
        const target = event.target;
        
        // 判斷點擊的是否為文字輸入框
        const isTextInput = target.tagName === 'INPUT' && target.type === 'text';
        const isTextarea = target.tagName === 'TEXTAREA';

        // 如果是，且沒有被標記為 'no-modal-editor'，就打開懸浮視窗
        if ((isTextInput || isTextarea) && !target.classList.contains('no-modal-editor') && target.id !== 'modal-textarea') {
            event.preventDefault(); // 阻止預設行為
            openModalEditor(target);
        }
    });

    // 為懸浮視窗的按鈕和外部區域綁定關閉事件
    modalSaveBtn.addEventListener('click', saveAndCloseEditor);
    modalCloseBtn.addEventListener('click', closeModalEditor);
    modal.addEventListener('click', function(event) {
        if (event.target === modal) {
            closeModalEditor();
        }
    });

    // --- OCR 整合邏輯 ---
    const ocrBtn = document.getElementById('modal-ocr-btn');
    let ocrWindow = null;
    
    // 【重要】請確保此URL與您的OCR工具部署的網址一致
    const VERCEL_OCR_URL = 'https://gemini-ocr-proxy.vercel.app/';
    
    if (ocrBtn) {
        ocrBtn.addEventListener('click', function() {
            if (ocrWindow && !ocrWindow.closed) {
                ocrWindow.focus();
                return;
            }
            ocrWindow = window.open(VERCEL_OCR_URL, 'OCRWindow', 'width=650,height=850,scrollbars=yes,resizable=yes');
        });
    }

    // 監聽來自OCR子視窗的訊息
    window.addEventListener('message', function(event) {
        // 安全性檢查：確保訊息來自您信任的OCR工具
        if (event.origin !== new URL(VERCEL_OCR_URL).origin) {
            return;
        }

        // 處理收到的OCR結果
        if (event.data && event.data.type === 'ocrResult') {
            const ocrText = event.data.text;
            
            // 將辨識文字附加到懸浮視窗的輸入框中
            modalTextarea.value += (modalTextarea.value.trim() ? '\n' : '') + ocrText;
            
            if (ocrWindow) {
                ocrWindow.close(); // 自動關閉OCR子視窗
            }
            
            modalTextarea.focus(); // 將焦點移回輸入框
        }
    });
});


</script>

<!-- === 通用輸入懸浮視窗 (從「神思」複製) === -->
<div id="outline-editor-modal" class="outline-modal-overlay">
    <div class="outline-modal-content">
        <h3 id="modal-title">編輯內容</h3>
        <textarea id="modal-textarea" rows="15"></textarea>
        <div class="modal-buttons">
            <!-- OCR 按鈕 -->
            <button id="modal-ocr-btn" class="btn-action" style="background-color: #17a2b8;">OCR</button>
            
            <!-- 確認輸入按鈕 -->
            <button id="modal-save-btn" class="btn-action">輸入</button>
        </div>
        <button id="modal-close-btn" class="preview-close-btn" title="關閉">&times;</button>
    </div>
</div>


<!-- === 1. Firebase SDK 引入 === -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

<!-- === 2. Firebase 初始化、持久化與 Token 注入器 === -->
<script>
    // 1. 定義 Firebase 設定
    const firebaseConfig = {
        apiKey: "AIzaSyBgwrgn2m343mRJb0WjzUhteiospegXhvI",
        authDomain: "sansidata.firebaseapp.com",
        projectId: "sansidata",
        storageBucket: "sansidata.firebasestorage.app",
        messagingSenderId: "580288358575",
        appId: "1:580288358575:web:35dcf4e79bcef530de4c5a",
        databaseURL: "https://sansidata-default-rtdb.firebaseio.com"
    };

    // 2. 初始化 Firebase
    if (typeof firebase !== 'undefined' && !firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }
    
    var database = firebase.database();
    var auth = firebase.auth();

    // 3. 啟動監聽與同步邏輯 (持久化)
    document.addEventListener('DOMContentLoaded', function() {
        if (auth) {
            auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
            .then(() => {
                auth.onAuthStateChanged(async (user) => {
                    const s = JSON.parse(localStorage.getItem('studentProfile'));

                    if (user) {
                        console.log("[ZiZhen] 🟢 偵測到有效登入:", user.email);
                        if (!s) {
                            console.log("[ZiZhen] 正在同步雲端身份...");
                            try {
                                const emailKey = btoa(user.email);
                                const snapshot = await database.ref('email_mapping/' + emailKey).once('value');
                                const profile = snapshot.val();
                                if (profile) {
                                    localStorage.setItem('studentProfile', JSON.stringify(profile));
                                    // window.location.reload(); // 可選：刷新以更新 UI
                                }
                            } catch (e) { console.error("同步失敗:", e); }
                        }
                    } else {
                        console.log("[ZiZhen] ⚪ 未偵測到登入");
                        if (s) {
                            console.warn("[ZiZhen] ⚠️ 發現失效的身份資料，執行安全清除...");
                            localStorage.removeItem('studentProfile');
                        }
                    }
                });
            })
            .catch((error) => console.error("[ZiZhen] 持久化設定失敗:", error));
        }
    });

    // 4. [核心] 全域請求攔截器 (Auto Token Injector)
    (function() {
        // 防止與嚴格鎖衝突，這裡針對後端 API 進行二次攔截
        const originalFetch = window.fetch; 
        const TARGET_URL_PART = "script.google.com"; // 攔截發往 GAS 的請求

        window.fetch = async function(url, options) {
            // 檢查是否為發往後端的 POST 請求
            if (typeof url === 'string' && url.includes(TARGET_URL_PART) && options && options.method === 'POST') {
                
                console.log("[TokenInjector] 偵測到後端請求，準備注入 Token...");

                const user = await new Promise((resolve) => {
                    if (firebase.auth().currentUser) {
                        resolve(firebase.auth().currentUser);
                    } else {
                        const unsubscribe = firebase.auth().onAuthStateChanged(u => {
                            unsubscribe();
                            resolve(u);
                        });
                        setTimeout(() => resolve(null), 2000);
                    }
                });

                if (user) {
                    try {
                        const token = await user.getIdToken(true);
                        let bodyData = JSON.parse(options.body);
                        bodyData.token = token; // ★ 強制注入 Token
                        options.body = JSON.stringify(bodyData);
                        console.log("[TokenInjector] Token 注入成功！");
                    } catch (e) {
                        console.error("[TokenInjector] Token 獲取失敗:", e);
                    }
                } else {
                    console.warn("[TokenInjector] 用戶未登入，無法注入 Token");
                    // 這裡不需阻擋，因為「嚴格權限鎖」已經在前面擋過了
                }
            }
            return originalFetch(url, options);
        };
    })();
</script>

<!-- === [還原版] 神思大數據收集模組 (30秒=1分鐘邏輯) === -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    let totalSeconds = 0;
    let timerInterval = null;

    // 1. 獲取日期路徑
    function getDateParts() {
        const now = new Date();
        const y = String(now.getFullYear());
        const m = String(now.getMonth() + 1).padStart(2, '0');
        const d = String(now.getDate()).padStart(2, '0');
        return { y, m, d };
    }

    // 2. 獲取身份
    function getIdentity() {
        const rawProfile = localStorage.getItem('studentProfile');
        let s = null;
        try { if(rawProfile) s = JSON.parse(rawProfile); } catch (e) {}

        if (s && s.grade && s.class) {
            const safeName = s.name.replace(/[.#$/[\]]/g, '_'); 
            return { type: 'student', id: s.uid || `stu_${s.grade}${s.class}_${safeName}`, grade: s.grade, class: s.class };
        } else {
            let guestID = localStorage.getItem('sansi_guest_uuid');
            if (!guestID) {
                guestID = 'guest_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('sansi_guest_uuid', guestID);
            }
            return { type: 'guest', id: guestID, grade: 'Guest', class: 'Visitor' };
        }
    }

// === 3. 記錄訪問 (Log Visit) - 高效分流版 ===
// === 3. 記錄訪問 (Log Visit) - 高效分流版 (含 stats_school 邏輯) ===
async function logVisitOnce() {
    if (typeof firebase === 'undefined' || !database) return;
    
    const { y, m, d } = getDateParts();
    const identity = getIdentity();
    const uid = identity.id;

    // Session 鎖
    const sessionKey = `sansi_visit_logged_${y}${m}${d}_${uid}`;
    if (sessionStorage.getItem(sessionKey)) return; 

    // 檢查 Tracking (判斷是否為今日首次)
    const trackingRef = database.ref(`stats_tracking/${y}/${m}/${d}/unique_users/${uid}`);
    
    try {
        const snap = await trackingRef.once('value');
        const isFirstTimeToday = !snap.exists();

        const updates = {};
        const increment1 = firebase.database.ServerValue.increment(1);
        
        // 1. 全校總覽路徑 (含訪客) - stats_global
        const globalPath = `stats_global/${y}/${m}/${d}`;
        updates[`${globalPath}/visits`] = increment1;

        // ★★★ 新增：純學校路徑 (僅學生) - stats_school ★★★
        const schoolPath = `stats_school/${y}/${m}/${d}`;

        if (identity.type === 'student') {
            const classKey = `${identity.grade}${identity.class}`;
            const studentKey = identity.id.split('_').pop(); // 名字

            // 學生同時寫入 stats_school
            updates[`${schoolPath}/visits`] = increment1;

            // 2. 班級路徑 (stats_classes/6A/YYYY/MM/DD)
            const classPath = `stats_classes/${classKey}/${y}/${m}/${d}`;
            updates[`${classPath}/visits`] = increment1;

            // 3. 學生路徑 (stats_students/6A/陳大文/YYYY/MM/DD)
            const studentPath = `stats_students/${classKey}/${studentKey}/${y}/${m}/${d}`;
            updates[`${studentPath}/visits`] = increment1;

            if (isFirstTimeToday) {
                updates[`stats_tracking/${y}/${m}/${d}/unique_users/${uid}`] = true;
                
                // 更新 global unique
                updates[`${globalPath}/unique`] = increment1;
                
                // ★ 更新 school unique (僅學生)
                updates[`${schoolPath}/unique`] = increment1;
                
                // 更新 class unique
                updates[`${classPath}/unique`] = increment1;
            }
        } else {
            // 訪客 (只寫入 global，不寫入 school)
            if (isFirstTimeToday) {
                updates[`stats_tracking/${y}/${m}/${d}/unique_users/${uid}`] = true;
                updates[`${globalPath}/unique`] = increment1;
            }
        }

        await database.ref().update(updates);
        sessionStorage.setItem(sessionKey, 'true');
        console.log("📍 [Stats] 訪問計數已分流上傳 (含 stats_school)");

    } catch (e) {
        console.error("Stats Error:", e);
    }
}

// 4. 上傳 1 分鐘 (分流版 - 除錯模式)
function uploadOneMinute() {
    if (typeof firebase === 'undefined' || !database) return;
    
    logVisitOnce(); 

    const { y, m, d } = getDateParts();
    const identity = getIdentity();
    
    // 獲取學生名稱 Key (防呆)
    const studentKey = identity.id.includes('_') ? identity.id.split('_').pop() : identity.name; 
    
    const updates = {};
    const increment60 = firebase.database.ServerValue.increment(60);

    // 1. 全域 (Global)
    updates[`stats_global/${y}/${m}/${d}/duration`] = increment60;

    // ★★★ 2. 學生身份判斷 ★★★
    if (identity.type === 'student') {
        const classKey = `${identity.grade}${identity.class}`;

        // Path A: 全校 (這是您缺少的)
        const pathSchool = `stats_school/${y}/${m}/${d}/duration`;
        updates[pathSchool] = increment60;

        // Path B: 班級
        const pathClass = `stats_classes/${classKey}/${y}/${m}/${d}/duration`;
        updates[pathClass] = increment60;
        
        // Path C: 個人
        const pathStudent = `stats_students/${classKey}/${studentKey}/${y}/${m}/${d}/duration`;
        updates[pathStudent] = increment60;

        // ★ 除錯訊息：請在 F12 Console 查看是否出現此行 ★
        console.log(`[Stats] 正在上傳時長... 目標包含: ${pathSchool}`);
    } else {
        console.log("[Stats] 當前為訪客身份，不寫入 stats_school");
    }

    database.ref().update(updates)
        .then(() => console.log("✅ [Stats] 時長上傳成功"))
        .catch(e => console.error("❌ [Stats] 上傳失敗 (請檢查 Rules):", e));
}

    // 5. 計時器啟動 (還原你的邏輯)
    function startTimer() {
        if (timerInterval) return;
        console.log("▶️ [Stats] 計時器啟動");
        
        timerInterval = setInterval(() => {
            totalSeconds++;
            
            // ★★★ 你的原始邏輯 ★★★
            // 30秒 -> 傳送 (算1分鐘)
            // 90秒 (1分30秒) -> 傳送 (算2分鐘)
            // 150秒 (2分30秒) -> 傳送 (算3分鐘)
            if (totalSeconds === 30 || (totalSeconds > 30 && (totalSeconds - 30) % 60 === 0)) {
                uploadOneMinute();
            }
        }, 1000);
    }

    function pauseTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
            console.log("⏸️ [Stats] 暫停計時 (當前累計: " + totalSeconds + "s)");
            // 注意：這裡不再有 uploadDuration(unsaved)，未滿的部分直接捨棄
        }
    }

    // 延遲啟動
    setTimeout(() => {
        logVisitOnce();
        startTimer();
    }, 3000);

    // 偵測頁面狀態
    document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden') pauseTimer();
        else startTimer();
    });
    
    window.forceLogVisit = logVisitOnce;
});
</script>

  <script>



// ★★★★★ 請將代碼貼在這裡 (原本的內容之下，script 結束標籤之上) ★★★★★

    // =======================================================
    // === [新增] 在線狀態自動報到系統 (Presence System) ===
    // =======================================================
    function initPresenceSystem() {
        // 延遲執行，確保 Firebase 已初始化且本地存儲已讀取
        setTimeout(() => {
            if (typeof database === 'undefined') return;

            // 1. 監聽連線狀態
            const connectedRef = database.ref('.info/connected');

            connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    // === 連線成功，準備資料 ===
                    
                    // 獲取用戶資料
                    const s = JSON.parse(localStorage.getItem('studentProfile'));
                    let myUid = "";
                    let userData = {};

                    // A. 判斷身分
                    if (s && s.name) {
                        // --- 已登入用戶 (學生/老師/特許) ---
                        const user = firebase.auth().currentUser;
                        myUid = user ? user.uid : `stu_${s.grade}${s.class}_${s.name}`;
                        
                        // 準備寫入的資料
                        userData = {
                            name: s.name,
                            grade: s.grade,
                            class: s.class,
                            timestamp: firebase.database.ServerValue.TIMESTAMP,
                            device: /Mobile|Android/i.test(navigator.userAgent) ? 'Mobile' : 'Desktop'
                        };
                    } else {
                        // --- 訪客 ---
                        let guestId = localStorage.getItem('sansi_guest_uuid');
                        if (!guestId) {
                            guestId = 'guest_' + Math.random().toString(36).substr(2, 9);
                            localStorage.setItem('sansi_guest_uuid', guestId);
                        }
                        myUid = guestId;

                        userData = {
                            name: "訪客",
                            grade: "Guest",
                            class: "Visitor",
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        };
                    }

                    // B. 執行 Firebase 動作
                    const myPresenceRef = database.ref(`online_users/${myUid}`);

                    // 關鍵指令：當客戶端斷線時，自動刪除這筆資料
                    myPresenceRef.onDisconnect().remove().then(() => {
                        // 斷線指令設定成功後，寫入當前狀態
                        myPresenceRef.set(userData);
                    });
                }
            });
        }, 2000); // 延遲 2 秒啟動
    }

    // 啟動報到系統
    document.addEventListener('DOMContentLoaded', initPresenceSystem);



	
</script>

  
</body>
</html>
